{"title":"前端单元测试框架的实现原理","date":"2023-01-13T21:47:50.000Z","date_formatted":{"ll":"Jan 13, 2023","L":"01/13/2023","MM-DD":"01-13"},"link":"2023/01/13/前端单元测试原理","comments":true,"tags":["单元测试"],"categories":["front-end"],"updated":"2023-07-11T08:54:19.192Z","content":"<h2 id=\"关于单元测试\">关于单元测试<a title=\"#关于单元测试\" href=\"#关于单元测试\"></a></h2>\n<p>先看维基百科：</p>\n<blockquote>\n<p>在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p>\n</blockquote>\n<p>在前端背景下，这个也可以很简单理解为测试工具函数。通常来说，单元测试，关于验证我们应用中每一个函数是否调用正确。如何判断调用正确呢？考虑一般如下：</p>\n<ul>\n<li>函数调用次数合理</li>\n<li>函数入参符合预期</li>\n<li>函数出参，也即是返回值符合预期</li>\n</ul>\n<p>当然函数本身可能又会调用其他函数，或者也可以说函数会依赖其他模块、第三方库，同时函数也可能是同步或异步。所以当被测试的函数是纯函数时，就是测试函数本身的出入参是否符合预期就行了，否则，我们需要做许多 mock 的工作，借此来排除不是我们目标的测试代码。</p>\n<p>当然我们日常工作中，如果要写单元测试的话，一般都会使用业界成熟的测试库，比如 jest、mocha、chai、ava、tape、QUnit 等等。其实大部分测试框架背后的原理基本类似。所以，让我们通过实现一个最简单的单元测试框架，来学习单元测试原理吧！</p>\n<h2 id=\"测试容器和断言库\">测试容器和断言库<a title=\"#测试容器和断言库\" href=\"#测试容器和断言库\"></a></h2>\n<p>测试框架基本可以拆分出两个部分：</p>\n<ul>\n<li>测试容器（Test Runner）</li>\n<li>断言库（Assertion Library）</li>\n</ul>\n<h3 id=\"简介\">简介<a title=\"#简介\" href=\"#简介\"></a></h3>\n<p>测试容器最基本的作用是，自动运行所有测试，对测试结果进行数据汇总等。我们常见的使用方式一般如下，编写测试单元：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./math.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; sumAsync, subtractAsync &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./math&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"string\">&#x27;sumAsync adds numbers asynchronously&#x27;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"title function_\">sumAsync</span>(<span class=\"number\">3</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> expected = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"title function_\">expect</span>(result).<span class=\"title function_\">toBe</span>(expected);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"string\">&#x27;subtractAsync subtracts numbers asynchronously&#x27;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"title function_\">subtractAsync</span>(<span class=\"number\">7</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> expected = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"title function_\">expect</span>(result).<span class=\"title function_\">toBe</span>(expected);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>假设我们有 math 工具函数如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./math.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">sum</span> = (<span class=\"params\">a, b</span>) =&gt; a + b;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">subtract</span> = (<span class=\"params\">a, b</span>) =&gt; a - b;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">sumAsync</span> = (<span class=\"params\">...args</span>) =&gt; <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"title function_\">sum</span>(...args));</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">subtractAsync</span> = (<span class=\"params\">...args</span>) =&gt; <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"title function_\">subtract</span>(...args));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123; sum, subtract, sumAsync, subtractAsync &#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们用 jest 运行测试，在终端反馈汇总后的测试结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jest</span><br><span class=\"line\"> PASS  ./math.test.js</span><br><span class=\"line\">  ✓ sumAsync adds numbers asynchronously (4ms)</span><br><span class=\"line\">  ✓ subtractAsync subtracts numbers asynchronously (1ms)</span><br><span class=\"line\"></span><br><span class=\"line\">Test Suites: 1 passed, 1 total</span><br><span class=\"line\">Tests:       2 passed, 2 total</span><br><span class=\"line\">Snapshots:   0 total</span><br><span class=\"line\">Time:        1.145s</span><br><span class=\"line\">Ran all <span class=\"built_in\">test</span> suites.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>断言库一般形式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">expect</span>(result).<span class=\"title function_\">toBe</span>(expected);</span><br><span class=\"line\"><span class=\"title function_\">expect</span>(func).<span class=\"title function_\">toHaveBeenCalled</span>();</span><br><span class=\"line\"><span class=\"title function_\">expect</span>(func).<span class=\"title function_\">toHaveBeenCalledTimes</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"title function_\">expect</span>(func).<span class=\"title function_\">toHaveBeenCalledWith</span>(arg1, arg2 <span class=\"comment\">/* ...args  */</span>);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>断言库是不是看起来很语义化~</p>\n<h3 id=\"测试容器实现示例\">测试容器实现示例<a title=\"#测试容器实现示例\" href=\"#测试容器实现示例\"></a></h3>\n<p>测试容器其实并不复杂，最简单的实现不过如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./test.js</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\">title, callback</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">callback</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`✓ <span class=\"subst\">$&#123;title&#125;</span>`</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">`✕ <span class=\"subst\">$&#123;title&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>需要留意的是，这里加上了 async/await 是为了等待测试用例中的异步逻辑。</p>\n<h3 id=\"断言库实现示例\">断言库实现示例<a title=\"#断言库实现示例\" href=\"#断言库实现示例\"></a></h3>\n<p>断言库也没有黑魔法，我们写一个最简单的 expect(x).toBe(y) 的语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./expect.js</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">expect</span>(<span class=\"params\">actual</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">toBe</span>(<span class=\"params\">expected</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (actual !== expected) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;actual&#125;</span> is not equal to <span class=\"subst\">$&#123;expected&#125;</span>`</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>远比想象中简单，对不对~</p>\n<p>这里有个比较关键的地方是，断言函数里如果断言失败时，我们的选择是抛出一个错误，然后在测试容器中会 try/catch 捕获，同时打印错误堆栈。（在简单情况下，我们也可以使用 Node.js 自带的 assert 库进行断言）</p>\n<p>除此之外，还有很多更复杂的断言语法，不过基本形式也就是这样。当然如何巧妙设计测试函数调用次数（toHaveBeenCalledTimes）、出入参（toHaveBeenCalledWith）的断言函数，后文会提到。</p>\n<h3 id=\"自动注入\">自动注入<a title=\"#自动注入\" href=\"#自动注入\"></a></h3>\n<p>有些同学可能留意到了，在测试框架中，我们并不需要手动引入 test、expect 这些函数，每个测试文件可以直接使用。这个其实也很简单。参考代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./test-framework.js</span></span><br><span class=\"line\"><span class=\"comment\">// 注入给全局对象，使得每个文件可以访问</span></span><br><span class=\"line\"><span class=\"variable language_\">global</span>.<span class=\"property\">test</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./test&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">global</span>.<span class=\"property\">expect</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./expect&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从命令行加载所有测试用例：</span></span><br><span class=\"line\">process.<span class=\"property\">argv</span>.<span class=\"title function_\">slice</span>(<span class=\"number\">2</span>).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">file</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 测试文件中</span></span><br><span class=\"line\">  <span class=\"built_in\">require</span>(file);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然后在终端运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node test-framework.js ./math.test.js</span><br><span class=\"line\">✓ sumAsync adds numbers asynchronously</span><br><span class=\"line\">✓ subtractAsync subtracts numbers asynchronously</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对不对！就是这么简单！</p>\n<p>接下来我们只需要把这件事情做得更优雅，比如</p>\n<ul>\n<li>把它封装成 TestRunner 对象</li>\n<li>把命令放在 ./bin 中</li>\n<li>扩展更多的断言语法</li>\n<li>使用 glob 匹配所有测试文件</li>\n<li>支持配置（参考 jest.config.js）</li>\n<li>测试汇总统计</li>\n<li>支持优雅的错误堆栈</li>\n</ul>\n<p>甚至于你可以扩展进行支持 DOM 测试，因为 DOM 测试的核心逻辑也是使用 JSDOM 根据 W3C 标准在内存中模拟相似的 DOM 结构，从而支持断言测试的。</p>\n<h2 id=\"函数测试\">函数测试<a title=\"#函数测试\" href=\"#函数测试\"></a></h2>\n<p>上文中我们基本搭建了一个最简单的测试框架，文件结构如下：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── expect.js</span><br><span class=\"line\">├── <span class=\"built_in\">math</span>.js</span><br><span class=\"line\">├── <span class=\"built_in\">math</span>.test.js</span><br><span class=\"line\">├── test-framework.js</span><br><span class=\"line\">└── test.js</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>说起来，在某些场景下，其实我们需要能够保证函数只被执行一次，以及被调用时候的入参是准确的。</p>\n<p>因为函数调用多次可能会引发内存泄露，入参错误则可能会导致应用不可预期的行为。所以我们需要从断言库中更细粒度的去测试保障。</p>\n<p>那么断言库是怎么做到的呢？</p>\n<p>接下来我们将扩展一下断言库，使其支持更丰富的函数测试。</p>\n<h3 id=\"入参与调用次数监控的实现原理\">入参与调用次数监控的实现原理<a title=\"#入参与调用次数监控的实现原理\" href=\"#入参与调用次数监控的实现原理\"></a></h3>\n<p>假设我们扩展支持这两种断言语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">expect</span>(sum).<span class=\"title function_\">toHaveBeenCalledTimes</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"title function_\">expect</span>(sum).<span class=\"title function_\">toHaveBeenCalledWith</span>(<span class=\"number\">3</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>大家可以思考一下如何设计实现呢？</p>\n<p>我们在测试框架中，集成下面这个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./test-framework.js</span></span><br><span class=\"line\"><span class=\"variable language_\">global</span>.<span class=\"property\">jest</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">fn</span>: <span class=\"function\">(<span class=\"params\">impl = () =&gt; &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">mockFn</span> = (<span class=\"params\">...args</span>) =&gt; &#123;</span><br><span class=\"line\">      mockFn.<span class=\"property\">mock</span>.<span class=\"property\">calls</span>.<span class=\"title function_\">push</span>(args);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title function_\">impl</span>(...args);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    mockFn.<span class=\"property\">originImpl</span> = impl;</span><br><span class=\"line\">    mockFn.<span class=\"property\">mock</span> = &#123; <span class=\"attr\">calls</span>: [] &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mockFn;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>其中的 fn 函数是一个高阶函数，包裹传入的待测试函数 impl。挂载 mock 对象，在返回的 mockFn 中调用时，用以统计调用数据。</p>\n<p>当然对于编写测试用例的调用方来说是无需感知的，只需要使用 jest.fn 进行包裹即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sumMockFn = jest.<span class=\"title function_\">fn</span>(sum);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>接下来只需要对返回的 sumMockFn 进行测试即可，本质上对 sumMockFn 的操作，都会透传到 sum 中。</p>\n<h3 id=\"扩展断言函数\">扩展断言函数<a title=\"#扩展断言函数\" href=\"#扩展断言函数\"></a></h3>\n<p>所以我们还差什么？… 嗯对了。还有断言函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./expect</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; isEqual &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;lodash&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">expect</span>(<span class=\"params\">actual</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">toBe</span>(<span class=\"params\">expected</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">toEqual</span>(<span class=\"params\">expected</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"title function_\">isEqual</span>(actual, expected)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;actual&#125;</span> is not equal to <span class=\"subst\">$&#123;expected&#125;</span>`</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">toHaveBeenCalledTimes</span>(<span class=\"params\">expected</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> actualCallTimes = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        actualCallTimes = actual.<span class=\"property\">mock</span>.<span class=\"property\">calls</span>.<span class=\"property\">length</span>;</span><br><span class=\"line\">        <span class=\"title function_\">expect</span>(actualCallTimes).<span class=\"title function_\">toEqual</span>(expected);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(</span><br><span class=\"line\">          <span class=\"string\">`expect function: <span class=\"subst\">$&#123;actual.originImpl.toString()&#125;</span> to call <span class=\"subst\">$&#123;expected&#125;</span> times, but actually call <span class=\"subst\">$&#123;actualCallTimes&#125;</span> times`</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">toHaveBeenCalledWith</span>(<span class=\"params\">...expectedArgs</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> actualCallArgs = [];</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        actualCallArgs = actual.<span class=\"property\">mock</span>.<span class=\"property\">calls</span>;</span><br><span class=\"line\">        actualCallArgs.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">callArgs</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">expect</span>(callArgs).<span class=\"title function_\">toEqual</span>(expectedArgs);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(</span><br><span class=\"line\">          <span class=\"string\">`expect function: <span class=\"subst\">$&#123;actual.originImpl.toString()&#125;</span> to be called with <span class=\"subst\">$&#123;expectedArgs&#125;</span>, but actually it was called with <span class=\"subst\">$&#123;actualCallArgs&#125;</span>`</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>别看代码有点长，其实细看很简单对不对。关键点就是对 jest.fn 包裹过后的函数挂载的对象 mock 长度、内容进行断言。这里需要留意的是。我们捕获了 <code>expect(x).toEqual(y)</code> 抛出的错误，抛出了一个对用户更友好的错误。</p>\n<p>终于，我们编写测试用例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"string\">&#x27;sum should have been called once&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sumMockFn = jest.<span class=\"title function_\">fn</span>(sum);</span><br><span class=\"line\">  <span class=\"title function_\">sumMockFn</span>(<span class=\"number\">3</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">  <span class=\"title function_\">expect</span>(sumMockFn).<span class=\"title function_\">toHaveBeenCalledTimes</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"string\">&#x27;sum should have been called with `3` `7`&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sumMockFn = jest.<span class=\"title function_\">fn</span>(sum);</span><br><span class=\"line\">  <span class=\"title function_\">sumMockFn</span>(<span class=\"number\">3</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">  <span class=\"title function_\">expect</span>(sum).<span class=\"title function_\">toHaveBeenCalledWith</span>(<span class=\"number\">3</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>成功运行！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node test-framework.js ./math.test.js</span><br><span class=\"line\">✓ <span class=\"built_in\">sum</span> should have been called once</span><br><span class=\"line\">✓ <span class=\"built_in\">sum</span> should have been called with `3` `7`</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"模块\">模块<a title=\"#模块\" href=\"#模块\"></a></h2>\n<p>经过我们的努力。我们已经做了一个像模像样的测试框架了。但是请等等！现实真的有这么简单么？</p>\n<p>突然需要测试一个新的函数，这个函数好像有点不一样…</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./user.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">v4</span>: uuidv4 &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;uuid&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">createUser</span>(<span class=\"params\">&#123; name, age &#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"attr\">id</span>: <span class=\"title function_\">uuidv4</span>(),</span><br><span class=\"line\">      name,</span><br><span class=\"line\">      age,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们想要测试这个函数返回带有一个 id 的用户对象，同时也调用了 uuidv4。但是发现这个函数没办法编写测试，因为每次生成的 id 不一样，所以它每次返回对象都不一样。没办法简单的使用 <code>expect(x).toEqual(y)</code>。</p>\n<p>但是我们不可能去测试 uuid 库。因为测试它们是毫无意义的，也是不现实的。</p>\n<p>那怎么办呢？我们还是有办法的。扩展测试框架如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./test-framework.js</span></span><br><span class=\"line\"><span class=\"variable language_\">global</span>.<span class=\"property\">jest</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">fn</span>: <span class=\"function\">(<span class=\"params\">impl = () =&gt; &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mock</span>: <span class=\"function\">(<span class=\"params\">mockPath, mockExports = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>.<span class=\"title function_\">resolve</span>(mockPath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">require</span>.<span class=\"property\">cache</span>[path] = &#123;</span><br><span class=\"line\">      <span class=\"attr\">id</span>: path,</span><br><span class=\"line\">      <span class=\"attr\">filename</span>: path,</span><br><span class=\"line\">      <span class=\"attr\">loaded</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">exports</span>: mockExports,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们发现上面的 mock 函数使用 require.resolve 获取了模块加载路径，然后在 require.cache 准备好构造后的缓存导出对象。</p>\n<p>编写测试如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./user.test.js</span></span><br><span class=\"line\">jest.<span class=\"title function_\">mock</span>(<span class=\"string\">&#x27;uuid&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">v4</span>: <span class=\"function\">() =&gt;</span> <span class=\"string\">&#x27;FAKE_ID&#x27;</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; createUser &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"string\">&#x27;create an user with id&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userData = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;Christina&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">25</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> expectUser = &#123;</span><br><span class=\"line\">    ...userData,</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"string\">&#x27;FAKE_ID&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">expect</span>(<span class=\"title function_\">createUser</span>(userData)).<span class=\"title function_\">toEqual</span>(expectUser);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>因为 require.cache 的关系，我们需要把 jest.mock 提到文件最前面调用。（jest 里同样的操作不需要提前，那是因为测试框架在运行测试用例时自动提前此类操作了）然后模拟导出的 v4 对象返回一个 FAKE_ID。</p>\n<p>运行测试如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node test-framework.js ./user.test.js</span><br><span class=\"line\">✓ create an user with <span class=\"built_in\">id</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>完美解决~</p>\n<p>真实世界里的应用函数往往不会是干净可爱的纯函数，依赖大量第三方流行库进行开发是我们的日常，也是开源世界里一件幸福的事情。</p>\n<p>如何排除第三方依赖库进行测试，基本原理也是如上。</p>\n<h2 id=\"让它更优雅\">让它更优雅<a title=\"#让它更优雅\" href=\"#让它更优雅\"></a></h2>\n<p>每次都要调用 <code>node test-framework.js ./user.test.js</code> 来运行测试，看上去不是很好。我们让这个测试框架变得更优雅吧！</p>\n<p>嗯，我们给这个测试框架起个名字，就叫 mjest 吧！</p>\n<p>第一步，我们在项目新建 bin 目录，将上文的测试框架的实现丢进 ./bin/mjest.js 中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tree ./bin/</span><br><span class=\"line\">./bin/</span><br><span class=\"line\">└── mjest.js</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>第二步，在 mjest.js 文件顶部加入 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FShebang\" title=\"https://zh.wikipedia.org/wiki/Shebang\" target=\"_blank\">Shebang</a>。使用 node 作为默认解释器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env node</span></span><br><span class=\"line\"></span><br><span class=\"line\">// mjest code</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>第三步，在 package.json 中加入 bin 声明：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;mjest&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;mini jest implementation&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;main&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;index.js&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;bin&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;mjest&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./bin/mjest.js&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>第四步，在项目路径终端下运行 <code>npm link</code>。该命令会将项目的 bin 软链接到系统中 bin 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">which</span> mjest</span><br><span class=\"line\">/Users/sulirc/.nvm/versions/node/v10.20.1/bin/mjest</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>第五步！使用热乎乎刚出炉的 mjest 运行测试用例吧：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mjest ./user.test.js</span><br><span class=\"line\">✓ create an user with <span class=\"built_in\">id</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mjest ./math.test.js</span><br><span class=\"line\">✓ <span class=\"built_in\">sum</span> should have been called once</span><br><span class=\"line\">✓ <span class=\"built_in\">sum</span> should have been called with `3` `7`</span><br><span class=\"line\">✓ sumAsync adds numbers asynchronously</span><br><span class=\"line\">✓ subtractAsync subtracts numbers asynchronously</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们也可以用 glob 语法更优雅的匹配文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mjest *.test.js</span><br><span class=\"line\">✓ <span class=\"built_in\">sum</span> should have been called once</span><br><span class=\"line\">✓ <span class=\"built_in\">sum</span> should have been called with `3` `7`</span><br><span class=\"line\">✓ create an user with <span class=\"built_in\">id</span></span><br><span class=\"line\">✓ sumAsync adds numbers asynchronously</span><br><span class=\"line\">✓ subtractAsync subtracts numbers asynchronously</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>本文的完整测试框架代码，笔者也已经放在 github 上，欢迎阅读：<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsulirc%2Fmjest\" title=\"https://github.com/sulirc/mjest\" target=\"_blank\">github.com/sulirc/mjes…</a></p>\n<h2 id=\"更多\">更多<a title=\"#更多\" href=\"#更多\"></a></h2>\n<p>到此为止，相信大家应该对测试框架原理基本有一定了解了。在 jest 中，还有比如 beforeEach、beforeAll 等钩子函数，大家也可以想办法自己实现。断言库里丰富的断言函数，也可以一个一个击破。</p>\n<p>不断丰富特性，四舍五入，我们就实现了一个测试框架。</p>\n<p>在单元测试的基础上，其实集成测试框架原理也相差不远。因为集成测试其实就是建立在单元测试上的。大家也可以进行思考。</p>\n<h2 id=\"转载\">转载<a title=\"#转载\" href=\"#转载\"></a></h2>\n<p><a href=\"https://juejin.cn/post/6868947498191290375#heading-1\" target=\"_blank\">深入浅出前端单元测试框架的实现原理</a></p>\n","prev":{"title":"windows 系统的包管理器","link":"2023/01/17/windows系统的包管理器"},"next":{"title":"esbuild 为什么快","link":"2022/11/18/esbuild为什么快"},"plink":"https://becase.top/2023/01/13/前端单元测试原理/","toc":[{"id":"关于单元测试","title":"关于单元测试","index":"1"},{"id":"测试容器和断言库","title":"测试容器和断言库","index":"2","children":[{"id":"简介","title":"简介","index":"2.1"},{"id":"测试容器实现示例","title":"测试容器实现示例","index":"2.2"},{"id":"断言库实现示例","title":"断言库实现示例","index":"2.3"},{"id":"自动注入","title":"自动注入","index":"2.4"}]},{"id":"函数测试","title":"函数测试","index":"3","children":[{"id":"入参与调用次数监控的实现原理","title":"入参与调用次数监控的实现原理","index":"3.1"},{"id":"扩展断言函数","title":"扩展断言函数","index":"3.2"}]},{"id":"模块","title":"模块","index":"4"},{"id":"让它更优雅","title":"让它更优雅","index":"5"},{"id":"更多","title":"更多","index":"6"},{"id":"转载","title":"转载","index":"7"}],"reading_time":"3187 words in 21 min"}