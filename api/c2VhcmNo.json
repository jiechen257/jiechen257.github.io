[{"title":"新兴的Astro","date":"2023-04-23T21:47:50.000Z","date_formatted":{"ll":"Apr 23, 2023","L":"04/23/2023","MM-DD":"04-23"},"updated":"2023-07-11T08:54:19.196Z","content":"Astro\n框架定位\n接下来聊一聊 Astro 框架的定位，是像 Vue、React 这样的底层渲染框架，还是像 Next.js 这种上层的研发框架？\n这一点其实挺困扰初学者的，因为 Astro 既自创了类似于.vue、.jsx文件的 .astro 语法，又提供了像 Next.js 里面各种运行时的能力，比如约定式路由、构建优化、SSR 等等。\n但实际上它给自己的定位非常清晰，即 content-focused 应用开发框架，换句话说，就是重内容、轻交互场景下的上层研发框架，比如大多数电商网站、文档站、博客站、证券网站等等。\n你可以将 Astro 理解为一个垂直场景下的Next.js，但它可以在它适用的领域里面可以胜过其它所有竞品(如Next.js、Remix、Vuepress 等)，这是它能够做起来的重要原因。接下来，我们就来看看 Astro 的优势在于哪些地方。\n核心优势\nAstro 的主要优势包括如下几点:\n\nIslands 架构，解决传统 SSR/SSG 框架的全量 hydration 问题，做到尽可能少的 Client 端 JS 的开销，甚至是 0 JS。\n学习成本低。.astro 语法和传统的 .jsx 和 .vue 非常相似，对于新手前端来说也比较容易掌握。\n使用灵活。对于页面的开发，你既可以使用官方的.astro 语法，也同样可以使用 .md、.vue、.jsx 语法，也就是说，你可以自由选择其它前端框架的语法来开发，甚至可以在一个项目中同时写 Vue 组件和 React 组件！\n构建迅速。底层构建体系基于 Vite 以及 Esbuild 实现，项目启动速度非常快。\n\nIslands 架构\n在如上的几个优点中，我们来重点说一说 Astro 的 Islands 架构，因为这是它高性能最主要的原因。\nIslands 架构模型早在 2019 年就被提出来了，并在 2021 年被 Preact 作者Json Miller 在Islnads Architecture 一文中得到推广。这个模型主要用于 SSR (也包括 SSG) 应用，我们知道，在传统的 SSR 应用中，服务端会给浏览器响应完整的 HTML 内容，并在 HTML 中注入一段完整的 JS 脚本用于完成事件的绑定，也就是完成 hydration (注水) 的过程。当注水的过程完成之后，页面也才能真正地能够进行交互。\n那么当应用的体积逐渐增大时，需要在客户端执行的 JS 脚本也会越来越多，这也意味着 TTI(可交互时间) 指标越来越高:\n为了解决这个问题，Islands 架构将页面拆分为各自独立的组件，包含静态组件和可交互组件，如下图的例子所示：\n\n可以清楚的看到，一个页面中只有部分的组件交互，那么对于这些可交互的组件，我们可以并行地执行 hydration 过程，因为组件之间是互相独立的。\n而对于静态组件，即不可交互的组件，我们可以让其不参与 hydration 过程，直接复用服务端下发的 HTML 内容。\n可交互的组件就犹如整个页面中的孤岛(Island)，因此这种模式叫做 Islands 架构:\n\n相比于传统 SSR 中的全量 hydration，Islands 模式可以实现局部(partial) hydration，从而优化 JS 的体积，减少网络传输的成本和 JS 运行时的开销。\n在 Astro 中，默认所有的组件都是静态组件，比如:\n1234// index.astroimport MyReactComponent from &#x27;../components/MyReactComponent.jsx&#x27;;---&lt;MyReactComponent /&gt;\n值得注意的是，这种写法不会在浏览器添加任何的 JS 代码。但有时我们需要在组件中绑定一些交互事件，那么这时就需要激活孤岛组件了，在 Astro 如何来激活呢？其实很简单，在使用组件时加上client:load指令即可:\n12345// index.astro---import MyReactComponent from &#x27;../components/MyReactComponent.jsx&#x27;;---&lt;MyReactComponent client:load /&gt;\n如此一来，Astro 会给浏览器传输一部分 JS 代码供这个组件完成 hydration，以便后续的交互。\nAstro 2.0\n\n内容集合：Markdown 和 MDX 的自动类型安全；\n混合渲染：支持静态渲染和动态渲染；\n重新设计的错误 Overlays；\n改进的开发服务器 (HMR)；\nVite 4.0；\n新的公开路线图\n\n详情参考：Astro 2.0正式发布，现代化静态站点生成器 - 掘金\nSSR和SSG\n1. 静态资源和动态资源分别是什么？\n首先静态资源和动态资源都是服务端这边的概念，因为我们访问互联网本质都是访问对应的服务端\n对于服务端来说：\n\n静态资源是：提前准备好的，写死了的，直接文件IO就可以response的属于静态资源。\n动态资源是：不是写死的，需要读库的 或 需要调下游接口的 或 需要脚本处理的属于动态资源\n\n前端角度看哪些是静态资源？\n\n通过前端工程npm run build编译好的js、css、html文件，都属于静态资源\n提前准备好的文件（比如自己开发的源代码），都属于静态资源\n图片、视频等资源文件，都属于静态资源\n\n前端角度看哪些是动态资源？\n\n需要调接口才能得到的内容，并且内容不是提前准备好的，属于动态资源\n\n2. 从架构角度看动、静态资源\n1. 请求SSR架构的服务的html属于静态资源还是动态资源？\n结论：属于动态资源\n因为：html没有提前准备好，没有提前静态化。是来一个请求，就动态编译生成html的\n2. 请求SSG架构的服务的html属于静态资源还是动态资源？\n结论：属于静态资源\n因为：html被提前静态化了。无需实时编译\n3. 引发对性能优化的思考\nSSR架构的存在问题，以及如何解决\nSSR架构性能好是最大的特色之一，但被人诟病的一个最大问题也是性能问题，原因：\n\n\nSSR架构的性能好，其实是针对前端来说的\n\n\n对于前端用户来说，访问SSR的服务，可以直接得到完整的html（CSR架构的html是空的，没有dom内容，dom内容需等js后续生成的），\n\n\n并且如果你的首屏需要被多个接口阻塞时，SSR可以在服务端把请求处理完\n\n\n服务端处理请求非常非常快，举个栗子：同一个接口前端ajax需要1s，服务端请求可能只需20ms，因为服务端可以抹掉网络连接的阻塞，可能和目标下游服务器就在同一个机房\n\n\n\n\nSSR架构对于服务端来说，性能非常差\n\n这个怎么理解呢？ 其实是和服务端接口来做对比的，比如接口的QPS可以很容易超过1000，但SSR的处理QPS可能只有10，因为html是动态生成的，需要大量的时间来编译得到html，所以对于接口来说，SSR的性能很差很差\n\n\n\n解决办法\n\n\n做成SSG（静态化）\n\n\n原理：提前编译好html，节省编译html的时间，让 请求动态资源 变成 请求静态资源。\n\n\n但也不是没副作用的，副作用是：会丢失动态化能力，比如我本来可以在服务端根据用户的ip，显示对应的语言的html。做成SSG之后，只能默认显示一种语言。并且也无法在服务端把阻塞请求处理完\n\n\n\n\n不过有办法可以解决上面SSG架构的缺陷（动静结合！）\n\n\n原理：在多加一层bff层，由这一层来处理动态化部分\n\n\n比如 把阻塞请求处理完，通过&#123;&#123; &#125;&#125;占位标识，替换掉对应html内的数据。\n\n\n比如 根据用户ip显示多语言的问题，需要我们提前用ssg编译好多份html（对应多语言），然后由bff来处理。。（确实做的有点复杂了，不过假如要追求极致性能的话，这是一种选择）\n\n\n\n\n\n\n参考\nAstro 1.0 正式发布，给前端带来了什么\n对静态资源和动态资源的思考，延伸至SSR和SSG的性能优化\n","plink":"https://becase.top/2023/04/23/新兴的Astro/"},{"title":"初识WebComponent","date":"2023-02-16T21:47:50.000Z","date_formatted":{"ll":"Feb 16, 2023","L":"02/16/2023","MM-DD":"02-16"},"updated":"2023-07-11T08:54:19.192Z","content":"背景\n\n组件化 已经成为目前主流的前端开发模式，其可复用性这一大特点是一众复制粘贴工程师的福音。目前我们实现组件化主要是依托于各大框架如 Vue ， React ， Angular 。这些框架基本都是在遵从浏览器的规则下制定出自己的一套开发规则和书写语法使开发者的项目获得组件化的能力\n\n随着近年来组件化框架的盛行，官方也推行了一套组件化的解决方案和原生API上的支持 —— Web Component 。\nWeb Component 是什么\nWeb Components 是一系列加入 w3c 的 HTML 和 DOM 的特性，使得开发者可以创建可复用的组件\n\n由于 web components 是由 w3c 组织去推动的，因此它很有可能在不久的将来成为浏览器的一个标配。\n\n关键字：原生、定制化标签\n使用 Web Component 编写的组件是脱离框架的，换言之，也就是说使用 Web Component 开发的组件库，是适配所有框架的，不会像 Antd 这样需要对 Vue 、 React 等框架出不同的版本\n使用 Web Component\nWeb Component 核心技术\n\nCustom elements（自定义元素）：一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们\nShadow DOM（影子DOM）：一组 JavaScript API，用于将封装的 “影子” DOM 树 附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突\nHTML templates（HTML模板）： &lt; template &gt; 和 &lt; slot &gt; 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用\nHTML Imports（HTML导入）：一旦定义了 自定义组件，最简单的重用它的方法就是使其定义细节保存在一个单独的文件中，然后使用导入机制将其导入到想要实际使用它的页面中。 HTML 导入就是这样一种机制，尽管存在争议 — Mozilla 根本不同意这种方法，并打算在将来实现更合适的\n\n实现一个简单的组件\n\n定义自定组件:12345678class MyButton extends HTMLElement &#123;\tconstructor () &#123;\t\tsuper();\t\tconst template = document.getElementById(&#x27;mybutton&#x27;);\t\tconst content = template.content.cloneNode(true);\t\tthis.appendChild(content);\t&#125;&#125;\n\n\n（神似 react）\n\n\n定义组件模板:\n123&lt;template id=&quot;mybutton&quot;&gt;\t&lt;button&gt;Add&lt;/button&gt;&lt;/template&gt;\n\n\n注册组件:\n1window.customElements.define(&#x27;my-button&#x27;, MyButton);\n\n\n使用组件:\n123&lt;body&gt;\t&lt;my-button&gt;&lt;/my-button&gt;&lt;/body&gt;\n\n\n这样， 一个简单的 Web Component 就完成了。\n生命周期\n和一般框架中的组件一样，Web Component 的组件为了支持更多场景的应用也是有生命周期的。\n常用的生命周期方法如下:\n\nconnectedCallback\n当 web component 被添加到 DOM 时，会调用这个回调函数，这个函数只会被执行一次。可以在这个回调函数中完成一些初始化操作，比如更加参数设置组件的样式。\ndisconnectedCallback\n当 web component 从文档 DOM 中删除时执行。\nadoptedCallback\n当 web component 被移动到新文档时执行。\nattributeChangedCallback\n被监听的属性发生变化时执行\n\n与React的结合\n就像刚刚所使用的，看起来 WebComponent 和 React 很想，但实际上二者是互补的关系\nReact中使用的API都是声明式的，react封装了对DOM的操作并做了一定的优化； 而WebComponent中则是命令式的，它的方法都是基于原生DOM进行操作的（要不然咋说它是原生组件技术，doge）\nreact官方也有说明，详情参考：Web Components – React\n在 Web Component 中使用 React\n1234567891011class XSearch extends HTMLElement &#123;  connectedCallback() &#123;    const mountPoint = document.createElement(&#x27;span&#x27;);    this.attachShadow(&#123; mode: &#x27;open&#x27; &#125;).appendChild(mountPoint);    const name = this.getAttribute(&#x27;name&#x27;);    const url = &#x27;https://www.google.com/search?q=&#x27; + encodeURIComponent(name);    ReactDOM.render(&lt;a href=&#123;url&#125;&gt;&#123;name&#125;&lt;/a&gt;, mountPoint);  &#125;&#125;customElements.define(&#x27;x-search&#x27;, XSearch);\n在 React 中使用 Web Component\n12345class HelloMessage extends React.Component &#123;  render() &#123;    return &lt;div&gt;Hello &lt;x-search&gt;&#123;this.props.name&#125;&lt;/x-search&gt;!&lt;/div&gt;;  &#125;&#125;\n\nWeb Components 的组件 video 可能会公开 play() 和 pause() 方法。要访问 Web Components 的命令式 API，你需要使用 ref 直接与 DOM 节点进行交互\n如果你使用的是第三方 Web Components，那么最好的解决方案是编写 React 组件包装该 Web Components。\n\nWeb Components 触发的事件可能无法通过 React 渲染树正确的传递。 你需要在 React 组件中手动添加事件处理器来处理这些事件。\ndemo演示\n\n如果我们想要实现原生组件复用，就需要把代码写在一个js文件里面，引入该js文件，就等于引入了组件。\n123456789101112131415161718192021222324252627//index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;    //引入编写好的组件，在这里引入文件，注意要添加defer关键字  &lt;script src=&quot;./MyList/index.js&quot; defer&gt;&lt;/script&gt;  &lt;body&gt;    &lt;div&gt;        //使用组件      &lt;my-list id=&quot;node&quot;&gt;          &lt;!--原生支持插槽  --&gt;        &lt;slot&gt;web component&lt;/slot&gt;      &lt;/my-list&gt;    &lt;/div&gt;    &lt;script&gt;        //因为是原生，所以我们需要获取dom节点行后续操作      const node = document.getElementById(&quot;node&quot;);        //我们将变量转换一下格式，就能传递给子组件      node.dataset.arr = JSON.stringify([&quot;吃饭&quot;, &quot;睡觉&quot;]);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//index.jsconst template = document.createElement(&quot;template&quot;);//在js文件中，我们想要书写html和css就必须要借助innerHTML，在其内部书写我们的样式和结构template.innerHTML = `  &lt;style&gt;    #contain &#123;      display: flex;      flex-direction: column    &#125;    input &#123;      width: 200px    &#125;  &lt;/style&gt;  &lt;div id=&quot;contain&quot;&gt;    &lt;span&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt;    &lt;div&gt;     &lt;input type=&quot;text&quot; id=input&gt;     &lt;button id=&quot;mybutton&quot; data-text1=&quot;111111&quot;&gt;添加&lt;/button&gt;    &lt;/div&gt;  &lt;/div&gt;`;class MyList extends HTMLElement &#123;  constructor() &#123;    //因为我们的组件继承于HTMLElement，所以需要调用super关键字      super();    // 获取标签    const content = template.content.cloneNode(true);    const mybutton = content.getElementById(&quot;mybutton&quot;);    const input = content.getElementById(&quot;input&quot;);    const contain = content.getElementById(&quot;contain&quot;);    // 获取props    const arr = JSON.parse(this.dataset.arr);   //进行事件的监听    mybutton.addEventListener(&quot;click&quot;, () =&gt; &#123;      arr.push(input.value)      const li = document.createElement(&quot;li&quot;);      li.innerText = input.value;      contain.appendChild(li);    &#125;);    // 将数据渲染到页面    arr.forEach((item) =&gt; &#123;      const li = document.createElement(&quot;li&quot;);      li.innerText = item;      contain.appendChild(li);    &#125;);     //初始化一个影子dom    this.attachShadow(&#123; mode: &quot;closed&quot; &#125;).appendChild(content);  &#125;&#125;// 注册组件window.customElements.define(&quot;my-list&quot;, MyList);\n相应框架\n从上面的案例看的出来这种原生dom操作的开发效率还是太低，这里再推荐一个WebComponent的封装框架：Stencil\n\n有人就疑惑了，WebComponent不是强调不依赖vue、react等框架吗？\n\n是的，它是不依赖vue、react等框架，但并不表示他不能像js拥有jQuery一样，拥有自己的封装库。\n封装出来的语法题和强依赖的运行环境，二者的关系需要弄清楚\n框架使用示例\n123456789101112131415161718192021import &#123; Component, Prop, h &#125; from &#x27;@stencil/core&#x27;;@Component(&#123;  tag: &#x27;my-component&#x27;,            // the name of the component&#x27;s custom HTML tag  styleUrl: &#x27;my-component.css&#x27;,   // css styles to apply to the component  shadow: true,                   // this component uses the ShadowDOM&#125;)export class MyComponent &#123;  // The component accepts two arguments:  @Prop() first: string;  @Prop() last: string;   //The following HTML is rendered when our component is used  render() &#123;    return (      &lt;div&gt;        Hello, my name is &#123;this.first&#125; &#123;this.last&#125;      &lt;/div&gt;    );  &#125;&#125;\n使用\n1&lt;my-component first=&quot;Stencil&quot; last=&quot;JS&quot;&gt;&lt;/my-component&gt;\n参考\nWeb Component | MDN\nWeb Component入门\nStencil\n","plink":"https://becase.top/2023/02/16/初识WebComponent/"},{"title":"windows 系统的包管理器","date":"2023-01-17T00:00:00.000Z","date_formatted":{"ll":"Jan 17, 2023","L":"01/17/2023","MM-DD":"01-17"},"updated":"2023-07-11T08:54:19.192Z","content":"\n大家都听说过 linux 的 apt、yum 等，MacOS 的 homebrew，那 windows 系统的包管理器呢？\nwindows 有没有包管理器，有的话为什么没多少人用？\n\n什么是包管理器\n\n包管理器又称软件包管理系统，它是在电脑中自动安装、配置、卸载和升级软件包的工具组合，在各种系统软件和应用软件的安装管理中均有广泛应用。\n\n如果你用过 Python ，那么对 pip 一定不陌生，Python 对所有第三方库的查找、下载、安装、卸载等都可以通过 pip 来完成的。需要哪个库，pip install帮你安装；不需要了，pip uninstall一键就能卸载。简单省事、方便快捷。不少编程语言均有各自对应的包管理器，比如 Nodejs 的 npm 等。\n其实在操作系统上，包管理器应用就更广泛了，尤其是 Linux 系统和 macOS 系统已经相当成熟了。比如 Ubuntu 的 apt、CentOS 的 yum、 macOS 系统下的 Homebrew 等\nWindows 平台的包管理器因为 支持下载的软件包少、国内下载速度慢、社区不完善 等问题仍受诟病，因此使用的人数很少，以至于有些人都没听说过 windows 系统也有包管理器\nWindows 系统上常见的包管理器主要有 Chocolatey、winget 和 Scoop。\n包管理器的作用\n\n降低安装维护软件的成本\n避免安装大量软件造成的路径污染\n不必查找和安装软件的其他依赖项\n避免捆绑和垃圾软件\n彻底地卸载\n\nChocolatey 的安装使用\n环境要求\n在安装之前，必须要保证自己电脑满足以下标准：\n\nWindows 7+ / Windows Server 2003+\nPowerShell v2+\n.NET Framework 4+\n\n安装\n右键开始菜单，选择用管理员权限打开 Windows Powershell(管理员)(A) \n12Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))复制代码\n等待安装完成，之后可以使用 choco -v 查看安装结果,也可以使用 choco -? 查看帮助文档\n使用\nChocolatey 的默认下载地址是在C 盘，如果你想更改默认下载位置，可以通过修改电脑的环境变量来实现\n\nchoco list/search [应用名]\n搜索应用\nchoco info [应用名]\n列出应用的详细信息\nchoco install [软件包名]\n显然就是来安装软件的\n-y 选项来默认确认安装\nchoco list/search -l\n查看本地安装的所有应用\nchoco list/search [应用名] --by-id-only\n只返回 id 中含有关键字的应用\nchoco uninstall [应用名]\n自动卸载应用（一个或多个）\nchoco outdated\n检查一下哪些应用需要更新\nchoco update all\n更新所有的软件\n当然你也可以直接用 choco upgrade [应用名] 更新某一个软件\n\n除了命令行界面，还有 ChocolateyGUI 图形界面以供使用\nwinget 的安装和使用\nWinGet（Windows 程序包管理器：Windows Package Manager）是微软为 win10 开发的一款开源的软件包管理器，于 2020 年 5 月的 Microsoft Build 开发者大会上 首宣 。\n前提：Windows 10 1709 及以上版本\n当前 WinGet 支持的安装程序类型尚不多，除了 EXE、MSIX、MSI 三种之外，还能够在自定义配置后下载部分微软应用商店的程序\n安装\n你可以在 Github Release 下载.appxbundle格式的文件，双击打开并运行（官方 GitHub 主页 和 Microsoft Docs 里有 WinGet 更详细配置信息）\n基本使用\n\n显示简略帮助文档：winget -?（-?可选）；查看特定命令的详细帮助文档：winget [&lt;命令&gt;] -?，如 winget install -?\n显示软件详细信息：winget show &lt;包名&gt;\n搜索软件：winget search &lt;包名&gt;\n安装软件：winget install &lt;包名&gt;\n\nScoop\nScoop 功能更全面、可配置性更高\n下载安装\n前提：\n\nWindows 7 SP1+ / Windows Server 2008\nPowerShell 5+（include PowerShell Core and .NET Framework 4.5 ）\n\n安装\n管理员身份运行 PowerShell，输入以下两条命令，待安装完成之后，输入 scoop 显示帮助文档即说明安装成功。\n12Set-ExecutionPolicy RemoteSigned -scope CurrentUseriwr -useb get.scoop.sh | iex\n注：Scoop 支持利用 aria2 进行多线程下载。所以可先 scoop install aria2 下载 aria2，之后所有的下载任务就均可以调用 aria2 多线程下载来提高速度了\n使用\n\n换源\n要改善 Scoop 的下载速度，详细可以参照 Scoop | Gitee 版 的说明更换下载源。换源之后的Scoop，速度提升不是一星半点儿。\n\n更换 Scoop 源\n\n123scoop config SCOOP_REPO https://gitee.com/squallliu/scoopscoop update\n\n更换 bucket 源\n\n1234567scoop install git# 注意：引号里面换成自己的路径，如果是默认路径则为$&#123;Env:USERPROFILE&#125;\\scoop\\buckets\\&lt;bucket_name&gt;git -C &quot;D:\\Scoop\\buckets\\main&quot; remote set-url origin https://hub.fastgit.org/ScoopInstaller/Main.gitgit -C &quot;D:\\Scoop\\buckets\\extras&quot; remote set-url origin https://hub.fastgit.org/lukesampson\n参考\nChocolatey Software | Chocolatey - The package manager for Windows\nWindows 系统缺失的包管理器：Chocolatey、WinGet 和 Scoop\n","plink":"https://becase.top/2023/01/17/windows系统的包管理器/"},{"title":"前端单元测试框架的实现原理","date":"2023-01-13T21:47:50.000Z","date_formatted":{"ll":"Jan 13, 2023","L":"01/13/2023","MM-DD":"01-13"},"updated":"2023-07-11T08:54:19.192Z","content":"关于单元测试\n先看维基百科：\n\n在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。\n\n在前端背景下，这个也可以很简单理解为测试工具函数。通常来说，单元测试，关于验证我们应用中每一个函数是否调用正确。如何判断调用正确呢？考虑一般如下：\n\n函数调用次数合理\n函数入参符合预期\n函数出参，也即是返回值符合预期\n\n当然函数本身可能又会调用其他函数，或者也可以说函数会依赖其他模块、第三方库，同时函数也可能是同步或异步。所以当被测试的函数是纯函数时，就是测试函数本身的出入参是否符合预期就行了，否则，我们需要做许多 mock 的工作，借此来排除不是我们目标的测试代码。\n当然我们日常工作中，如果要写单元测试的话，一般都会使用业界成熟的测试库，比如 jest、mocha、chai、ava、tape、QUnit 等等。其实大部分测试框架背后的原理基本类似。所以，让我们通过实现一个最简单的单元测试框架，来学习单元测试原理吧！\n测试容器和断言库\n测试框架基本可以拆分出两个部分：\n\n测试容器（Test Runner）\n断言库（Assertion Library）\n\n简介\n测试容器最基本的作用是，自动运行所有测试，对测试结果进行数据汇总等。我们常见的使用方式一般如下，编写测试单元：\n123456789101112131415// ./math.test.jsconst &#123; sumAsync, subtractAsync &#125; = require(&#x27;./math&#x27;);test(&#x27;sumAsync adds numbers asynchronously&#x27;, async () =&gt; &#123;  const result = await sumAsync(3, 7);  const expected = 10;  expect(result).toBe(expected);&#125;);test(&#x27;subtractAsync subtracts numbers asynchronously&#x27;, async () =&gt; &#123;  const result = await subtractAsync(7, 3);  const expected = 4;  expect(result).toBe(expected);&#125;);\n假设我们有 math 工具函数如下：\n12345678// ./math.jsconst sum = (a, b) =&gt; a + b;const subtract = (a, b) =&gt; a - b;const sumAsync = (...args) =&gt; Promise.resolve(sum(...args));const subtractAsync = (...args) =&gt; Promise.resolve(subtract(...args));module.exports = &#123; sum, subtract, sumAsync, subtractAsync &#125;;\n我们用 jest 运行测试，在终端反馈汇总后的测试结果：\n1234567891011$ jest PASS  ./math.test.js  ✓ sumAsync adds numbers asynchronously (4ms)  ✓ subtractAsync subtracts numbers asynchronously (1ms)Test Suites: 1 passed, 1 totalTests:       2 passed, 2 totalSnapshots:   0 totalTime:        1.145sRan all test suites.\n断言库一般形式如下：\n123456expect(result).toBe(expected);expect(func).toHaveBeenCalled();expect(func).toHaveBeenCalledTimes(1);expect(func).toHaveBeenCalledWith(arg1, arg2 /* ...args  */);// ...\n断言库是不是看起来很语义化~\n测试容器实现示例\n测试容器其实并不复杂，最简单的实现不过如下：\n1234567891011// ./test.jsasync function test(title, callback) &#123;  try &#123;    await callback();    console.log(`✓ $&#123;title&#125;`);  &#125; catch (error) &#123;    console.error(`✕ $&#123;title&#125;`);    console.error(error);  &#125;&#125;\n需要留意的是，这里加上了 async/await 是为了等待测试用例中的异步逻辑。\n断言库实现示例\n断言库也没有黑魔法，我们写一个最简单的 expect(x).toBe(y) 的语法如下：\n1234567891011// ./expect.jsfunction expect(actual) &#123;  return &#123;    toBe(expected) &#123;      if (actual !== expected) &#123;        throw new Error(`$&#123;actual&#125; is not equal to $&#123;expected&#125;`);      &#125;    &#125;,  &#125;;&#125;\n远比想象中简单，对不对~\n这里有个比较关键的地方是，断言函数里如果断言失败时，我们的选择是抛出一个错误，然后在测试容器中会 try/catch 捕获，同时打印错误堆栈。（在简单情况下，我们也可以使用 Node.js 自带的 assert 库进行断言）\n除此之外，还有很多更复杂的断言语法，不过基本形式也就是这样。当然如何巧妙设计测试函数调用次数（toHaveBeenCalledTimes）、出入参（toHaveBeenCalledWith）的断言函数，后文会提到。\n自动注入\n有些同学可能留意到了，在测试框架中，我们并不需要手动引入 test、expect 这些函数，每个测试文件可以直接使用。这个其实也很简单。参考代码如下：\n1234567891011// ./test-framework.js// 注入给全局对象，使得每个文件可以访问global.test = require(&#x27;./test&#x27;);global.expect = require(&#x27;./expect&#x27;);// 从命令行加载所有测试用例：process.argv.slice(2).forEach(file =&gt; &#123;  // 测试文件中  require(file);&#125;);\n然后在终端运行：\n1234$ node test-framework.js ./math.test.js✓ sumAsync adds numbers asynchronously✓ subtractAsync subtracts numbers asynchronously\n对不对！就是这么简单！\n接下来我们只需要把这件事情做得更优雅，比如\n\n把它封装成 TestRunner 对象\n把命令放在 ./bin 中\n扩展更多的断言语法\n使用 glob 匹配所有测试文件\n支持配置（参考 jest.config.js）\n测试汇总统计\n支持优雅的错误堆栈\n\n甚至于你可以扩展进行支持 DOM 测试，因为 DOM 测试的核心逻辑也是使用 JSDOM 根据 W3C 标准在内存中模拟相似的 DOM 结构，从而支持断言测试的。\n函数测试\n上文中我们基本搭建了一个最简单的测试框架，文件结构如下：\n1234567.├── expect.js├── math.js├── math.test.js├── test-framework.js└── test.js\n说起来，在某些场景下，其实我们需要能够保证函数只被执行一次，以及被调用时候的入参是准确的。\n因为函数调用多次可能会引发内存泄露，入参错误则可能会导致应用不可预期的行为。所以我们需要从断言库中更细粒度的去测试保障。\n那么断言库是怎么做到的呢？\n接下来我们将扩展一下断言库，使其支持更丰富的函数测试。\n入参与调用次数监控的实现原理\n假设我们扩展支持这两种断言语法：\n123expect(sum).toHaveBeenCalledTimes(1);expect(sum).toHaveBeenCalledWith(3, 7);\n大家可以思考一下如何设计实现呢？\n我们在测试框架中，集成下面这个函数：\n12345678910111213// ./test-framework.jsglobal.jest = &#123;  fn: (impl = () =&gt; &#123;&#125;) =&gt; &#123;    const mockFn = (...args) =&gt; &#123;      mockFn.mock.calls.push(args);      return impl(...args);    &#125;;    mockFn.originImpl = impl;    mockFn.mock = &#123; calls: [] &#125;;    return mockFn;  &#125;,&#125;;\n其中的 fn 函数是一个高阶函数，包裹传入的待测试函数 impl。挂载 mock 对象，在返回的 mockFn 中调用时，用以统计调用数据。\n当然对于编写测试用例的调用方来说是无需感知的，只需要使用 jest.fn 进行包裹即可：\n12const sumMockFn = jest.fn(sum);\n接下来只需要对返回的 sumMockFn 进行测试即可，本质上对 sumMockFn 的操作，都会透传到 sum 中。\n扩展断言函数\n所以我们还差什么？… 嗯对了。还有断言函数：\n12345678910111213141516171819202122232425262728293031323334353637383940// ./expectconst &#123; isEqual &#125; = require(&#x27;lodash&#x27;);module.exports = function expect(actual) &#123;  return &#123;    toBe(expected) &#123;      // ...    &#125;,    toEqual(expected) &#123;      if (!isEqual(actual, expected)) &#123;        throw new Error(`$&#123;actual&#125; is not equal to $&#123;expected&#125;`);      &#125;    &#125;,    toHaveBeenCalledTimes(expected) &#123;      let actualCallTimes = 0;      try &#123;        actualCallTimes = actual.mock.calls.length;        expect(actualCallTimes).toEqual(expected);      &#125; catch (err) &#123;        throw new Error(          `expect function: $&#123;actual.originImpl.toString()&#125; to call $&#123;expected&#125; times, but actually call $&#123;actualCallTimes&#125; times`        );      &#125;    &#125;,    toHaveBeenCalledWith(...expectedArgs) &#123;      let actualCallArgs = [];      try &#123;        actualCallArgs = actual.mock.calls;        actualCallArgs.forEach(callArgs =&gt; &#123;          expect(callArgs).toEqual(expectedArgs);        &#125;);      &#125; catch (err) &#123;        throw new Error(          `expect function: $&#123;actual.originImpl.toString()&#125; to be called with $&#123;expectedArgs&#125;, but actually it was called with $&#123;actualCallArgs&#125;`        );      &#125;    &#125;,  &#125;;&#125;;\n别看代码有点长，其实细看很简单对不对。关键点就是对 jest.fn 包裹过后的函数挂载的对象 mock 长度、内容进行断言。这里需要留意的是。我们捕获了 expect(x).toEqual(y) 抛出的错误，抛出了一个对用户更友好的错误。\n终于，我们编写测试用例如下：\n123456789101112test(&#x27;sum should have been called once&#x27;, () =&gt; &#123;  const sumMockFn = jest.fn(sum);  sumMockFn(3, 7);  expect(sumMockFn).toHaveBeenCalledTimes(1);&#125;);test(&#x27;sum should have been called with `3` `7`&#x27;, () =&gt; &#123;  const sumMockFn = jest.fn(sum);  sumMockFn(3, 7);  expect(sum).toHaveBeenCalledWith(3, 7);&#125;);\n成功运行！\n1234$ node test-framework.js ./math.test.js✓ sum should have been called once✓ sum should have been called with `3` `7`\n模块\n经过我们的努力。我们已经做了一个像模像样的测试框架了。但是请等等！现实真的有这么简单么？\n突然需要测试一个新的函数，这个函数好像有点不一样…\n12345678910111213// ./user.jsconst &#123; v4: uuidv4 &#125; = require(&#x27;uuid&#x27;);module.exports = &#123;  createUser(&#123; name, age &#125;) &#123;    return &#123;      id: uuidv4(),      name,      age,    &#125;;  &#125;,&#125;;\n我们想要测试这个函数返回带有一个 id 的用户对象，同时也调用了 uuidv4。但是发现这个函数没办法编写测试，因为每次生成的 id 不一样，所以它每次返回对象都不一样。没办法简单的使用 expect(x).toEqual(y)。\n但是我们不可能去测试 uuid 库。因为测试它们是毫无意义的，也是不现实的。\n那怎么办呢？我们还是有办法的。扩展测试框架如下：\n123456789101112131415161718// ./test-framework.jsglobal.jest = &#123;  fn: (impl = () =&gt; &#123;&#125;) =&gt; &#123;    // ...  &#125;,  mock: (mockPath, mockExports = &#123;&#125;) =&gt; &#123;    const path = require.resolve(mockPath);    require.cache[path] = &#123;      id: path,      filename: path,      loaded: true,      exports: mockExports,    &#125;;  &#125;,&#125;;// ...\n我们发现上面的 mock 函数使用 require.resolve 获取了模块加载路径，然后在 require.cache 准备好构造后的缓存导出对象。\n编写测试如下：\n1234567891011121314151617181920// ./user.test.jsjest.mock(&#x27;uuid&#x27;, &#123;  v4: () =&gt; &#x27;FAKE_ID&#x27;,&#125;);const &#123; createUser &#125; = require(&#x27;./user&#x27;);test(&#x27;create an user with id&#x27;, () =&gt; &#123;  const userData = &#123;    name: &#x27;Christina&#x27;,    age: 25,  &#125;;  const expectUser = &#123;    ...userData,    id: &#x27;FAKE_ID&#x27;,  &#125;;  expect(createUser(userData)).toEqual(expectUser);&#125;);\n因为 require.cache 的关系，我们需要把 jest.mock 提到文件最前面调用。（jest 里同样的操作不需要提前，那是因为测试框架在运行测试用例时自动提前此类操作了）然后模拟导出的 v4 对象返回一个 FAKE_ID。\n运行测试如下：\n123$ node test-framework.js ./user.test.js✓ create an user with id\n完美解决~\n真实世界里的应用函数往往不会是干净可爱的纯函数，依赖大量第三方流行库进行开发是我们的日常，也是开源世界里一件幸福的事情。\n如何排除第三方依赖库进行测试，基本原理也是如上。\n让它更优雅\n每次都要调用 node test-framework.js ./user.test.js 来运行测试，看上去不是很好。我们让这个测试框架变得更优雅吧！\n嗯，我们给这个测试框架起个名字，就叫 mjest 吧！\n第一步，我们在项目新建 bin 目录，将上文的测试框架的实现丢进 ./bin/mjest.js 中。\n1234$ tree ./bin/./bin/└── mjest.js\n第二步，在 mjest.js 文件顶部加入 Shebang。使用 node 作为默认解释器。\n1234#!/usr/bin/env node// mjest code\n第三步，在 package.json 中加入 bin 声明：\n12345678910&#123;  &quot;name&quot;: &quot;mjest&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;mini jest implementation&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;bin&quot;: &#123;    &quot;mjest&quot;: &quot;./bin/mjest.js&quot;  &#125;&#125;\n第四步，在项目路径终端下运行 npm link。该命令会将项目的 bin 软链接到系统中 bin 中：\n123$ which mjest/Users/sulirc/.nvm/versions/node/v10.20.1/bin/mjest\n第五步！使用热乎乎刚出炉的 mjest 运行测试用例吧：\n123$ mjest ./user.test.js✓ create an user with id\n123456$ mjest ./math.test.js✓ sum should have been called once✓ sum should have been called with `3` `7`✓ sumAsync adds numbers asynchronously✓ subtractAsync subtracts numbers asynchronously\n我们也可以用 glob 语法更优雅的匹配文件：\n1234567$ mjest *.test.js✓ sum should have been called once✓ sum should have been called with `3` `7`✓ create an user with id✓ sumAsync adds numbers asynchronously✓ subtractAsync subtracts numbers asynchronously\n本文的完整测试框架代码，笔者也已经放在 github 上，欢迎阅读：github.com/sulirc/mjes…\n更多\n到此为止，相信大家应该对测试框架原理基本有一定了解了。在 jest 中，还有比如 beforeEach、beforeAll 等钩子函数，大家也可以想办法自己实现。断言库里丰富的断言函数，也可以一个一个击破。\n不断丰富特性，四舍五入，我们就实现了一个测试框架。\n在单元测试的基础上，其实集成测试框架原理也相差不远。因为集成测试其实就是建立在单元测试上的。大家也可以进行思考。\n转载\n深入浅出前端单元测试框架的实现原理\n","plink":"https://becase.top/2023/01/13/前端单元测试原理/"},{"title":"esbuild 为什么快","date":"2022-11-18T20:47:50.000Z","date_formatted":{"ll":"Nov 18, 2022","L":"11/18/2022","MM-DD":"11-18"},"updated":"2023-07-11T08:54:19.192Z","content":"大多数其他打包工具都是用 JavaScript 编写的，但是对于 JIT-compiled（just-in-time compiled，也叫做 run-time compilations、运行时编译，或者也叫做 dynamic translation 动态编译）语言来说，命令行应用程序的性能是最差的。\n每次运行打包器时，Javascript VM 都是第一次看到打包器的代码，没有任何优化提示\n当 esbuild 忙于解析你的 JavaScript 时，node 正忙于解析你的打包器的 JavaScript 代码。当 node 完成你的打包器代码的解析时，esbuild 可能已经退出并且你的打包器甚至还没有开始打包。\n也就是说其他打包器因为使用 JavaScript 编写，于是每次编译开始需要先解析打包器的代码，然后再去实际编译 JavaScript 代码，这样就会更慢。而 Go 不属于动态编译的语言，省去了这个步骤\n速度快的原因\nesbuild 内部打包速度优化的四个方面：\n\nesbuild 是用 Go 语言写的，并且编译为 native code\n大量使用并行，充分利用多核 CPU\nesbuild 中的所有内容都是从头编写的，没有使用第三方库\n内存得到有效利用\n\n下面我们分别来介绍一下：\n1. esbuild 是用 Go 语言写的，并且编译为 native code\n其他大多数打包器，因为使用 JavaScript 编写，于是每次编译开始需要先解析打包器的代码，然后再去实际编译 JavaScript 代码，这样就会更慢。而 Go 不属于动态编译的语言，省去了这个步骤。\n另外，Go 语言的核心是并行性，JavaScript 不是。Go 可以在线程直接共享内存，JavaScript 需要在线程之间序列化数据。Go 和 JavaScript 都有并行的垃圾收集器，但是 Go 的堆在所有线程间共享，JavaScript 每个线程都有单独的堆。根据测试，这似乎使 JavaScript 的并行性减少了一半，可能是因为 CPU 的内核，一半正在忙着为另一半进行垃圾收集。\n2. 大量使用并行\nesbuild 内部使用算法保证充分利用多核 CPU，编译过程有三个阶段：解析（parsing）、链接（linking）和代码生成（code generation），解析和代码生成这两个阶段包括了大部分工作，并且可以完全可以并行去做的（大部分情况下，链接是一个串行的任务）。\n由于上面提到的，所有线程都可以共享内存。当从不同的入口点，打包相同的 JavaScript 库时，任务可以轻松的被共享。大多数计算机都有多核，于是并行性会是一个非常大的优势。\n3. esbuild 中的所有内容都是从头编写的\nesbuild 没有使用第三方库，内容都是自己从头编写的，这样会使架构更加的可扩展，并拥有性能优势\n举个例子，很多打包工具使用了 Typescript 官网的编译器作为解析器，但是 Typescript 官方的解析器并没有把性能当作一个首要的考虑点。\n他们的代码内大量使用了megamorphic object shapes和不必要的dynamic property accesses(这两者会使 JavaScript 的运行速度减慢)\n而且在 Typescript 解析器的类型检查被禁用的情况下，貌似还是会执行类型检查。\nesbuild 自定义了 Typescript 的解析器\n4. 内存得到有效利用\n理想情况下，编译器的复杂度时 O(n)，所以如果你在处理大量的数据，内存的访问速度可能会严重影响性能。修改数据的次数越少，编译器运行的速度就会越快。\n举例来说，esbuild 只涉及三次整个 JavaScript AST\n\n\n\n用于词法分析、解析、作用域设置和符号声明\n\n\n\n\n绑定符号、最小化语法、把 JSX/TS 编译为 JS、把 ES-next 编译为 ES-2015\n\n\n\n\n最小化标识符、最小化空格、生成代码和 source map\n\n\n\n可以最大程度的重复利用 AST，其他打包器将这些步骤分开进行的，不是交叉进行\n","plink":"https://becase.top/2022/11/18/esbuild为什么快/"},{"title":"web前端加密是否有意义","date":"2022-11-07T22:04:58.000Z","date_formatted":{"ll":"Nov 7, 2022","L":"11/07/2022","MM-DD":"11-07"},"updated":"2023-07-11T08:54:19.192Z","content":"背景\n\n在 web 通信建立在 https 的基础上，是否还需要前端对用户密码的加密?\n\n有人会笑话说这不是废话吗，常识如此（我最开始看到这个问题就是这么想的)\n你若再问我为什么，我不假思索就会来上一句“有助于提高系统用户的安全性”\n可真的能 提高 系统用户的安全性”吗？？\n先回顾一下前后端交互的几个核心诉求\n前后端交互过程中的安全性诉求\n这里借用一个比喻：\nAlice（ 浏览器前端 ）和 Bob（服务器后端）到底可以怎么幽会。这个问题又会涉及到以下这些问题：\n\nAlice 怎么知道 Bob 是 Bob？\nBob 怎么知道 Alice 是 Alice?\nAlice 和 Bob 幽会中的 窃窃私语 如何不被Eve偷听到，甚至被Oscar串改呢？\n\n前两个问题被统称归为 Authenticity（认证），第三个问题可以被归为 Confidentiality（保密） 和 Integrity。\n对于一般人而言，以上三个问题的成熟解决方案实现现有 SSH 和 mTLS ，常用的就是是 HTTPS 即 HTTP over TLS（在 TLS 安全信道上 HTTP 通讯）\n关于系统用户安全性的提升\n直觉上大家都会觉得前端既然加密了，那对 该网站用户认证系统 的整体安全性肯定是有所帮助的，哪怕是 m + n + 1 的帮助也是帮助，即  用户认证安全性 = m + n + 1，（先记住这个概念，后面会再用到）\n\nm 指后端加密\n这里的 n 是指传统的 htttps\n1 则是前端用户加密\n\n实际上并非如此，因为你的这个 n 正是从 1 迭代而来的，二者并没有累加的关系，而是后浪和前浪的关系，以下是解释\nn 和 1 的关系\n先看案例：\n\n如果某一天，这个系统的数据库泄露了，黑客就直接拿到了每个用户的密码 md5 值 \n但此时，由于黑客知道密码是在前端进行哈希的，所以他不需要爆破出该 md5 对应的原文是什么，而是直接修改客户端向服务器发出的请求，把密码字段换成数据库中 MD5 就可以了\n由于与数据库中记录一致，直接就会登录成功。这跟 直接存储 明文密码 没有任何区别！！\n\n在这个类似中间人攻击的案例中，我们再分析 n 和 1 的实际映射对象\n\nn 指对信息传输通道所做的操作，可以是 https 加密传输等其他任何传输方式\n1 指对信息发送源头所做的操作，可以是前端对密文做的一切加密操作\n\n再来看案例中黑客如何爆破这个系统的，他无视掉了 1（对信息发送源头所做的操作），仅仅是干掉了 n（即信息传输通道所做的操作）这一操作，就干掉了这个认证系统\n——即此时认证系统的安全性完全取决于 n\n因此，这个公式应该变成  用户认证安全性 = m + n\n针对这些，现代密码学有一些“反常识”的方法，也能加强这一理解\n现代密码学\n1.A 可以向 B 证明自己拥有一个密码，但是如果 B 是假冒的验证者，A 不会透露关于密码的任何信息给 B。——“零知识证明”\n2.A 可以和 B 比较自己持有的一个值的大小关系，而不泄露这个值给对方。——“百万富翁问题”\n3.A 可以给 B 发来的一段信息进行 电子签名 ，而不知道信息的内容。——“ 盲签名 ”\n4.A 和 B 可以，在没有公正第三人的情况下，进行等概率胜负的博弈。——“电 子博弈 ”\n5.邮件服务，如果不考虑法律风险的话，是可以做到让服务器看不到你的邮件内容的。——PGP\n对用户认证系统安全性并没有帮助\n以上，我们可以明确前端密码加密对用户认证系统安全性 并没有帮助\n有些人会认为前端进行了加密，可以降低后台的安全性需求，这种错误的观念会造成系统的 安全漏洞\n实际上，我们不能对前端做任何的假设，所有跟安全相关的技术，都必须应用在传输通道和后台上\n其他意义\n如果跳出系统用户安全性的这个范围，前端对密码加密还是有一定意义的\n主要是防止这个网站用户密码破解后，被黑客拿去 撞库， 去验证用户在其他平台的账号\n你可能又会问，这不也是加强安全性了吗？不是，这是 社会工程学 上的意义\n每个网站自己的 用户认证安全性 与其他网站的安全性应当是独立的，这只能防止被窃听到原文的密码被攻击者用在社会学攻击上，而不能改善该网站的安全性\n结论\n回到一开始的问题，答案是：Web 前端密码加密没有意义，又有意义\n这个意义跟多数开发者所想的并不一致，它并不能改善该网站的安全性，它体现在社会工程学上\n参考\n Web 前端密码加密是否有意义？\n","plink":"https://becase.top/2022/11/07/web前端加密是否有意义/"},{"title":"关于图灵完备","date":"2022-11-03T00:00:00.000Z","date_formatted":{"ll":"Nov 3, 2022","L":"11/03/2022","MM-DD":"11-03"},"updated":"2023-07-11T08:54:19.192Z","content":"什么是图灵机\n\n图灵机（Turing Machine）是图灵在1936年发表的 “On Computable Numbers, with an Application to the Entscheidungsproblem”（《论可计算数及其在判定性问题上的应用》）中提出的 数学模型\n\n既然是数学模型，它就并非一个实体概念，而是架空的一个想法。在文章中图灵描述了它是什么，并且证明了， 只要图灵机可以被实现，就可以用来解决任何可计算问题 。\n图灵机结构\n图灵机的结构包括以下几个部分：\n\n一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。\n一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。\n一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。\n一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解 有限状态机，它便对应着有限状态机里的状态。\n一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号53的格子并看到其内容为0时，擦除，改写为1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。\n\n在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：\n\n当前所处位置\n当前格子内容\n\n来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“…011001…”）便作为输出，由人来解码为 自然语言。\n要重申一下，以上只是图灵机模型的内容，而非具体的实现。所谓的纸带和读写头都只是图灵提出的 抽象概念\n为便于理解打一个比方\n抽象比喻\n算盘虽然不是图灵机（因为它没有无限长的纸带，即无限的存储空间），但它的行为与图灵机一致。每一串算珠都是纸带上的一格，一串算珠上展示的数字便记录着当前格中的字符（可以是空白，可以是 12345 ）\n人类的手即是读写头，可以更改每串算珠的状态。算盘的运行遵循人脑中的算法，当算法结束，算盘停机\n图灵机可以解决什么问题\n假设 上述模型里所说的功能都能被以某种形式物理实现， 那么 任意可计算问题都可以被解决\n\n在计算机领域，或者说自动机领域，我们研究的一切问题都是计算问题（Computational Problem）。它泛指一切与计算相关的问题。\n\n计算问题的一些举例：\n\n给定一个正整数 n，判断它是否是质数\n给定一个 01 序列，把它们按位取反\n\n非计算问题的例子：\n\n今晚吃什么\n为什么太阳从东边升起\n\n计算问题有的可以解决，有的不可解决。这就引出了计算问题的可计算性（Computability）\n如上面的问题 1，我们当然可以找到一个算法来解决判断任意正整数 n 是否为质数的问题（比如从2遍历到 n-1，看 n 是否可以整除它）\n所以，问题 1 就是可计算的。\n也有一些不可计算的计算问题，比如著名的 停机问题（Halting Problem)\n\nHalting Problem: given the description of an arbitrary program and a finite input, decide whether the program finishes running or will run forever.\n\n12345它的表述是这样的：给定一段程序的描述和该程序的一个有效输入，运行此程序，那么程序最终是会终止，还是会死循环下去？它是一个不可判定问题（Undecidable Problem）。即不存在一个 **通用** 算法，可以在任意输入下解决此问题图灵在文章里很优雅的用反证法推翻了假设“假设有这么一个算法可以解决任何停机问题”，从而证明了这样的算法并不存在\n什么是图灵完备\n图灵完备性（Turing Completeness）是针对一套数据操作规则而言的概念。\n数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。\n当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性\n常见不完备原因\n图灵不完备的语言常见原因有循环或递归受限(无法写不终止的程序,如 while(true){}; ), 无法实现类似数组或列表这样的数据结构(不能模拟纸带). 这会使能写的程序有限\n缺点\n图灵完备可能带来坏处, 如C++的模板语言, 模板语言是在类型检查时执行, 如果编译器不加以检查,我们完全可以写出使得C++编译器陷入死循环的程序.\n图灵不完备也不是没有意义, 有些场景我们需要限制语言本身. 如限制循环和递归, 可以保证该语言能写的程序一定是终止的.\n直观理解图灵完备——Brainfuck 语言\n如今主流的编程语言（C++，Java，Python，以及等等等等）都是图灵完备的语言\n关于语言优劣之争也只是在其封装、优化等方面，以及因为这些区别而产生的“不同语言适用于不同情况”的争执。如果我们回到最底层，就会发现它们可以实现的功能其实完全一样，并且本质上就是一个图灵机\n在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令\n语言虽然极致轻量，它却是一门图灵完备的编程语言\n\nBrainfuck is fully Turing-complete.\n一门新语言功能语法很复杂，要用数学证明的方式确定性说明它图灵完备会很麻烦，但只要用这门新语言实现一个brainfuck的解释器，那么就必然证明了是图灵完备的\n\n示例\n先贴上一段 BF 的代码，体验一下它的画风：\n1++++++++ [ &gt; ++++ [ &gt; ++ &gt; +++ &gt; +++ &gt; + &lt;&lt;&lt;&lt; - ] &gt; + &gt; + &gt; - &gt;&gt; + [ &lt; ] &lt; - ] &gt;&gt;. &gt; ---. +++++++.. +++. &gt;&gt;. &lt; -. &lt;. +++. ------. --------. &gt;&gt; +. &gt; ++.\n这个程序编译运行后，控制台打印 “Hello World!”。\nBF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。\n语言里的 8 个有效字符分别是：\n123456789101112131415&gt; 指针向右移动一格&lt; 指针向左移动一格+ 使指针当前格数值加一- 使指针当前格数值减一. 把当前格数值按 ASCII 表输出到终端, 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格[ 当指针当前值为 0 时，程序跳转至与之对应的 ] 之后；否则程序正常执行] 程序跳转回与之对应的 [ 处\n有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 ‘A’ 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 ‘A’。\n123456+++++[&gt; +++++++++++++&lt; -]&gt;.\n解释：\n\n把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。\n循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。\n此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 ‘A’。\n\ngif示例\nBrainfuck Visualizer - FreddieRa - OpenProcessing\n参考\n什么是图灵完备\n","plink":"https://becase.top/2022/11/03/关于图灵完备/"},{"title":"TS类型体操刷题tips","date":"2022-08-27T14:14:33.000Z","date_formatted":{"ll":"Aug 27, 2022","L":"08/27/2022","MM-DD":"08-27"},"updated":"2023-07-11T08:54:19.192Z","content":"类型的运算结果都可以用接口来表示 —— type 声明才是万能的\n重载的简写\n123456789101112131415161718const is: &#123;    (name: string, state: boolean | undefined): string    (name: string): string  &#125; = (name: string, ...args: [boolean | undefined] | []) =&gt; &#123;    const state = args.length &gt;= 1 ? args[0]! : true    return name &amp;&amp; state ? `$&#123;statePrefix&#125;$&#123;name&#125;` : &#x27;&#x27;  &#125;  const B: &#123;    (name: string, state: boolean): string    (name: string): string&#125; = (name: string, ...args: [boolean] | []) =&gt; &#123;    console.log(name, ...args)    return &quot;ss&quot;&#125;B(&quot;cdjk&quot;, false)B(&quot;dfs&quot;)\n泛型中 extends 的约束\n123type MyPick&lt;T, K extends keyof T&gt; = &#123;  [P in K]: T[P] &#125;;\n需要注意的是 K 是一个 union，keyof T 也将 T 中的属性转换为一个 union。当我们使用 extends 来进行条件约束的时候，TS 会使用 union 分发 的特性自动遍历 union K 中的属性与 keyof T 中的属性进行比较。\n假设 K 为 ‘title’ | ‘completed’ | ‘invalid’ ，T 为 ‘title’ | ‘completed’ | ‘description’。它的过程如下\n123step1:  &#x27;title&#x27; extends &#x27;title&#x27; | &#x27;completed&#x27; | &#x27;description&#x27; //通过step2:  &#x27;completed&#x27; extends &#x27;title&#x27; | &#x27;completed&#x27; | &#x27;description&#x27; //通过step3:  &#x27;invalid&#x27; extends &#x27;title&#x27; | &#x27;completed&#x27; | &#x27;description&#x27; //未通过，报错\n如果比较成功则通过，失败则报错，这样我们就实现了所有的关键步骤，通过了所有的测试用例。\nkeyof any\n\nRecord&lt;K, V&gt;\n\n123type MyRecord&lt;K  extends keyof any, V&gt; = &#123;  [key in K]: V&#125;\n注意对象的键值只能是 number | string | symbol ,所以 K 需要被约束\n同时，可以使用 keyof any 来代替 number | string | symbol ，它返回对象键值类型的所有可能\n接口或者枚举类型中的 never\n\nOmit&lt;T, K&gt;\n\n使用 as never 来使一个元素消失。\n在 TS 中如果一个 union 中的元素是一个 never 类型的，那么 TS 认为这个元素是一个空值，会返回去除这个值之后的结果。\ninfer 的使用\n\nParameters&lt; T &gt;\n\n在这个条件语句 T extends (...args: infer P) =&gt; any ? P : T 中，infer P 表示待推断的函数参数。\n整句含义为：如果 T 能赋值给 (...args: infer P) =&gt; any，则结果是 (...args: infer P) =&gt; any 类型中的参数 P，否则返回为 T\ninfer 的作用：在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用\n1type MyParameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;\n以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。\n类中构造器的类型声明方式\n\nConstructorParameters&lt; T &gt;\n\nc:&#123; new(): T &#125; 和 c: new () =&gt; T 是一样的，后者是前者的简写，意即 C 的类型是对象类型且这个对象包含返回类型是 T(类的实例) 的构造函数\n12345678910111213141516// es6, T === new People()class People: new () =&gt; T &#123;    constructor(name, age)&#123;        this.name = name;        this.age = age;    &#125;&#125;// es5var People = /*#__PURE__*/_createClass(function People(name, age) &#123;  _classCallCheck(this, People);  _defineProperty(this, &quot;name&quot;, void 0);  _defineProperty(this, &quot;age&quot;, void 0);  this.name = name;  this.age = age;&#125;);\n字符串字面量和递归\n看到递归的时候，才真正意识到 ts 也是一门编程语言，而不是什么类型的银弹（silver bullet）\n123type LastChar&lt;T extends string&gt; = T extends `$&#123;infer F&#125;$&#123;infer R&#125;` ?  (R extends &#x27;&#x27; ? F : LastChar&lt;R&gt;) : never;\n元祖类型的属性 length\n\nLengthOfTuple&lt; T &gt;\n\n1type LengthOfTuple&lt;T extends any[]&gt; = T[&#x27;length&#x27;]\n关于 T extends $&#123;infer L&#125;.$&#123;infer R&#125;\n如果 T extends 字面量，则 R 表示剩余参数\n如果 T extends 元祖，则 R 表示第二个参数\n关于 Record&lt;string, unknown&gt;\n\nimplement IsEmptyType&lt; T &gt;\n\nRecord&lt;string, unknown&gt; 表示任意对象类型\n1234567// 首先判断是不是对象类型// 其次判断对象的键为空type IsEmptyType&lt;T&gt; =  T extends Record&lt;string, unknown&gt; ?    [keyof T] extends [never] ?      true : false    : false;\nany类型如何表示\n\nimplement IsAny&lt; T &gt;\n\n123456789101112// 想写出这道题必须了解：any 类型在和其他类型进行联合、交叉时等于 any 类型自身type WhatEverType = true;type AnotherWhatEverType = [];type A = WhatEverType &amp; any; // anytype B = WhatEverType | any; // anytype T = WhatEverType extends AnotherWhatEverType &amp; any ? true : false; // truetype Q = WhatEverType extends AnotherWhatEverType | any ? true : false; // truetype IsAny&lt;T&gt; = WhatEverType extends (AnotherWhatEverType &amp; T) ? true : false;// 举例type IsAny&lt;T&gt; = 0 extends 1 &amp; T ? true : false;\n","plink":"https://becase.top/2022/08/27/TS类型体操刷题tips/"},{"title":"SSL建立的三个随机数作用","date":"2022-05-27T22:01:01.000Z","date_formatted":{"ll":"May 27, 2022","L":"05/27/2022","MM-DD":"05-27"},"updated":"2023-07-11T08:54:19.192Z","content":"概述\n首先再重温下 TLS四次握手 的过程：\n\n客户端向服务端发送协议版本号、一个随机数和可以使用的加密方法\n服务端接受后，确认加密的方法，向客户端发送一个随机数和自己数字证书\n客户端首先检查数字证书是否有效，如果有效，就再生成一个随机数，用数字证书提供的公钥加密再发给服务端，同时提供一个前面所有内容的hash值发给服务端以供校验\n服务端接收后，使用自己的私钥对数据解密，同时也发一个前面所有内容的hash值供客户端校验\n\n双方再有了三个随机数之后，按照之前约定的加密方法，使用三个随机数生成一个密钥，之后双方通信，就是用这个密钥对数据加密后再传输\n其中有用到三个随机数，用来做什么，为什么是三个？\n分析\n具体过程，图示如下（1-9）：\n\n其中建立 SSL 的三个随机数分别是：\n\nClientHello 中存在的一个随机数，令为 A\nServerHello 中存在的一个随机数，令为 B\nClientKeyExchange中的随机密码串\n\n随机数的作用\n先看第三个随机数，这是一个被称为 Pre-master secret 的随机密码串，由加密算法提供\n当客户端生成了 Pre-master secret 后，结合原来的 A 和 B 使用算法算出一个 master secret ，根据这个推到出 hash secret和session secret，这两个结果完全是依据三个随机数推到出来的，只有双方知道\n通信：\n\n双方使用对称加密算法进行加密，用hash secret对HTTP报文做一次运算生成一个MAC，附在HTTP报文的后面，然后用session-secret加密所有数据（HTTP+MAC），然后发送。\n接收方则先用session-secret解密数据，然后得到HTTP+MAC，再用相同的算法计算出自己的MAC，如果两个MAC相等，证明数据没有被篡改\n\n\nMAC(Message Authentication Code)称为报文摘要，能够查知报文是否遭到篡改，从而保护报文的完整性\n\n为什么是三个\nSSL协议默认不信任 每个主机都能产生完全随机的随机数， 如果随机数不随机，那么 pre-master secret 就可能被破解（因为密钥交换算法是公开的算法），所以必须引入新的随机因素，那么客户端和服务器加上pre-master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一\n参考\nHTTPS通信的过程的三个随机数的作用\n为什么是三个随机数\n SSL_ 随机数_的作用\n","plink":"https://becase.top/2022/05/27/SSL建立的三个随机数作用/"},{"title":"状态管理工具的演变","date":"2022-05-27T21:47:50.000Z","date_formatted":{"ll":"May 27, 2022","L":"05/27/2022","MM-DD":"05-27"},"updated":"2023-07-11T08:54:19.196Z","content":"概述：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测\nStore模式\n将状态存到一个外部变量， this.$root.$data\n123456789101112var store = &#123;  state: &#123;    message: &#x27;Hello!&#x27;  &#125;,  setMessageAction (newValue) &#123;    // 发生改变记录点日志啥的    this.state.message = newValue  &#125;,  clearMessageAction () &#123;    this.state.message = &#x27;&#x27;  &#125;&#125;\n由于store的state值改变方式（mutation）只有通过触发action来操作，因此可以很容易跟踪到state的改变流程，出现错误也能通过日志明确错误位置\n\nstore并没有限制组件只能通过action来修改state\n由这一点演化得出了 Flux 架构\nFlux\nFlux是类似于MVC、MVVM之类的一种思想，它把一个应用分成四个部分\n——View、Action、Dispatcher、Store\n\nView视图层可以是通过vue或者react等框架实现，而View中的数据都是Store，Store改变就抛出一个事件，通知所有的订阅者（或者监听，不同的框架对应不同的数据响应技术）发生改变\nFlux要求，View要想修改Store，必须经过一套流程\n\n视图先要告诉Dispatcher，让Dispatcher dispatch 一个 action\nDispatcher 收到 View 发出的 action，然后转发给Store\nStore就触发相应的action来更新数据\n数据更新则伴随着 View 的更新\n\n注意：\n\nDispatcher的作用是接受所有的 Action。然后发给所有的 Store（Action可能是View触发的，也可能是其他地方触发的，如测试用例）\nStore的改变只能通过Action，Store不应该有公开的 Setter，所有的Setter都应该是私有的，只能有公开的 Getter\n具体Action的处理逻辑一般放在 Store 里\n\nFlux 特点： 单向流动\nRedux\n与 Flux 思想类似，\n但修改了 Flux 的一些特性：\n\n一个应用可以拥有多个Store\n多个Store间可能存在依赖关系\nStore 还封装了处理数据的逻辑\n\n\nStore\nRedux 里面只有一个 Store，整个应用的数据都在这个大 Store 里面。Store 的 State 不能直接修改，每次只能返回一个新的 State。Redux 整了一个 createStore 函数来生成 Store。\n12import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(fn);\nStore 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。这样不管 View 是用什么实现的，只要把 View 的更新函数 subscribe 一下，就可以实现 State 变化之后，View 自动渲染了。比如在 React 里，把组件的render方法或setState方法订阅进去就行。\nAction\n和 Flux 一样，Redux 里面也有 Action，Action 就是 View 发出的通知，告诉 Store State 要改变。Action 必须有一个 type 属性，代表 Action 的名称，其他可以设置一堆属性，作为参数供 State 变更时参考。\n1234const action = &#123;  type: &#x27;ADD_TODO&#x27;,  payload: &#x27;Learn Redux&#x27;&#125;;\nRedux 可以用 Action Creator 批量来生成一些 Action。\nReducer\nRedux 没有 Dispatcher 的概念，Store 里面已经集成了 dispatch 方法。store.dispatch()是 View 发出 Action 的唯一方法。\n1234567import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(fn);store.dispatch(&#123;  type: &#x27;ADD_TODO&#x27;,  payload: &#x27;Learn Redux&#x27;&#125;);\nRedux 用一个叫做 Reducer 的纯函数来处理事件。Store 收到 Action 以后，必须给出一个新的 State（就是刚才说的Store 的 State 不能直接修改，每次只能返回一个新的 State），这样 View 才会发生变化。这种 State 的计算过程就叫做 Reduce\n\n纯函数，即没有任何副作用\n\n对于相同的输入，永远都只会有相同发输出\n不会影响挖补的变量，也不会被外部变量影响\n不能改写参数\n\n\nRedux根据应用的状态和当前的 action 推导出新的 state：(previousState, action) =&gt; newState\n类比 Flux：(state, action) =&gt; state\n123question: 为什么叫做 Reducer 呢?—— reduce 是一个函数式编程的概念，经常和 map 放在一起说，简单来说，map 就是映射，reduce 就是归纳。映射就是把一个列表按照一定规则映射成另一个列表，而 reduce 是把一个列表通过一定规则进行合并，也可以理解为对初始值进行一系列的操作，返回一个新的值\n整体流程\n1、用户通过 View 发出 Action：\n1store.dispatch(action);\n2、然后 Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。\n1let nextState = xxxReducer(previousState, action);\n3、State 一旦有变化，Store 就会调用监听函数。\n1store.subscribe(listener);\n4、listener可以通过 store.getState() 得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。\n1234function listerner() &#123;  let newState = store.getState();  component.setState(newState);   &#125;\n对比 Flux\n和 Flux 比较一下：Flux 中 Store 是各自为战的，每个 Store 只对对应的 View 负责，每次更新都只通知对应的View：\n\nRedux 中各子 Reducer 都是由根 Reducer 统一管理的，每个子 Reducer 的变化都要经过根 Reducer 的整合：\n\n简单来说，Redux有三大原则： 单一数据源：Flux 的数据源可以是多个。 State 是只读的：Flux 的 State 可以随便改。 * 使用纯函数来执行修改：Flux 执行修改的不一定是纯函数。\nRedux 和 Flux 一样都是单向数据流\n与React 关系\nRedux 和 Flux 类似，只是一种思想或者规范，它和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。\n但是因为 React 包含函数式的思想，也是单向数据流，和 Redux 很搭，所以一般都用 Redux 来进行状态管理。为了简单处理 Redux 和 React UI 的绑定，一般通过一个叫 react-redux 的库和 React 配合使用，这个是 react 官方出的（如果不用 react-redux，那么手动处理 Redux 和 UI 的绑定，需要写很多重复的代码，很容易出错，而且有很多 UI 渲染逻辑的优化不一定能处理好）。\nRedux将React组件分为容器型组件和展示型组件，容器型组件一般通过connect函数生成，它订阅了全局状态的变化，通过mapStateToProps函数，可以对全局状态进行过滤，而展示型组件不直接从global state获取数据，其数据来源于父组件。\n\n如果一个组件既需要UI呈现，又需要业务逻辑处理，那就得拆，拆成一个容器组件包着一个展示组件。\nRedux-saga\nRedux处理异步操作，添加中间件后的产物\n官方文档：Redux-Saga\nDva\n官方定义：dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架\n简单理解，就是让使用 react-redux 和 redux-saga 编写的代码组织起来更合理，维护起来更方便\n\n之前我们聊了 redux、react-redux、redux-saga 之类的概念，大家肯定觉得头昏脑涨的，什么 action、reducer、saga 之类的，写一个功能要在这些js文件里面不停的切换。dva 做的事情很简单，就是让这些东西可以写到一起，不用分开来写了\n\n比如：\n123456789101112131415161718192021222324252627282930313233343536// 以前书写的方式是创建 sagas/products.js, reducers/products.js 和actions/products.js，然后把 saga、action、reducer 啥的分开来写，来回切换app.model(&#123;  // namespace - 对应 reducer 在 combine 到 rootReducer 时的 key 值  namespace: &#x27;products&#x27;,  // state - 对应 reducer 的 initialState  state: &#123;    list: [],    loading: false,  &#125;,  // subscription - 在 dom ready 后执行  subscriptions: [    function(dispatch) &#123;      dispatch(&#123;type: &#x27;products/query&#x27;&#125;);    &#125;,  ],  // effects - 对应 saga，并简化了使用  effects: &#123;    [&#x27;products/query&#x27;]: function*() &#123;      yield call(delay(800));      yield put(&#123;        type: &#x27;products/query/success&#x27;,        payload: [&#x27;ant-tool&#x27;, &#x27;roof&#x27;],      &#125;);    &#125;,  &#125;,  // reducers - 就是传统的 reducers  reducers: &#123;    [&#x27;products/query&#x27;](state) &#123;      return &#123; ...state, loading: true, &#125;;    &#125;,    [&#x27;products/query/success&#x27;](state, &#123; payload &#125;) &#123;      return &#123; ...state, loading: false, list: payload &#125;;    &#125;,  &#125;,&#125;);\nMobX\n官网：MobX 中文文档\n对比 Flux 体系的单向数据流方案，Mobx 的思想则是 ：任何源自应用状态的东西都应该自动地获得 ——状态只要一变，其他用到状态的地方就都跟着自动变\n\nFlux 或者说 Redux 的思想主要就是函数式编程（FP）的思想，所以学习起来会觉得累一些。而 MobX 更接近于面向对象编程，它把 state 包装成可观察的对象，这个对象会驱动各种改变。什么是可观察？就是 MobX 老大哥在看着 state 呢。state 只要一改变，所有用到它的地方就都跟着改变了。这样整个 View 可以被 state 来驱动。\n1234567891011const obj = observable(&#123;    a: 1,    b: 2&#125;)autoRun(() =&gt; &#123;    console.log(obj.a)&#125;)obj.b = 3 // 什么都没有发生obj.a = 2 // observe 函数的回调触发了，控制台输出：2\n上面的obj，他的 obj.a 属性被使用了，那么只要 obj.a 属性一变，所有使用的地方都会被调用。autoRun 就是这个老大哥，他看着所有依赖 obj.a 的地方，也就是收集所有对 obj.a 的依赖。当 obj.a 改变时，老大哥就会触发所有依赖去更新\nMobX 和 Flux、Redux 一样，都是和具体的前端框架无关的，也就是说可以用于 React（mobx-react) 或者 Vue（mobx-vue)。一般来说，用到 React 比较常见，很少用于 Vue，因为 Vuex 本身就类似 MobX，很灵活。如果我们把 MobX 用于 React 或者 Vue，可以看到很多 setState() 和 this.state.xxx = 这样的处理都可以省了。\n参考\nVuex、Flux、Redux、Redux-saga、Dva、MobX\n","plink":"https://becase.top/2022/05/27/状态管理工具的演变/"},{"title":"http协议的发展历程","date":"2022-05-26T22:02:58.000Z","date_formatted":{"ll":"May 26, 2022","L":"05/26/2022","MM-DD":"05-26"},"updated":"2023-07-11T08:54:19.192Z","content":"http1 的缺点\nhttp1.1 提出支持长链接和管道化。\n长链接：即可以在一个 http 连接上传输多个请求&amp;响应（http1.1 之前每个 http 链接只可以传输一对请求&amp;响应然后就断开链接）。\b 在没有管道化的情况下，一个连接上的下一个请求需要在前一个响应返回后再发出。（并发请求只能通过同时建立多个连接实现）\n问题：\n\n串行传输\nhttp同域并发连接限制带来的阻塞（6~8）个\n\n管道化：可以在一个 http 链接上同时发送多个请求 （可以克服同域并行连接限制带来的阻塞）\n\n服务器可以同时处理多个请求，但是必须按照请求的顺序返回结果（即使后面的请求先处理完成也还是需要缓存起来，等前面的请求处理完返回之后再返回）（对头阻塞：如果前一个请求处理的时间过长或者被无线挂起，那么后面的请求就会排队等待）\n\n问题：\n\nHTTP 请求无法很好地利用多路复用，不允许一个连接上的多个响应数据交错返回(多路复用)。因而一个响应必须完全返回后，下一个响应才会开始传输。\n对头阻塞\n\n线头阻塞\nHTTP 管线化要求服务器按照接收到的请求顺序进行响应，如果管线化中的单个请求执行得很慢，客户端的后续 响应 也会相应的延迟下去\n\n解决办法\n客户端在主机上建立多个 TCP 连接\n\n连接的开销并没有消失\n\n再加上 ssl/tls 的加密通信使用，大多数浏览器设置了 最大可能同时连接数 来寻求平衡\n为什么限制并发连接数？\n\n每个连接都需要占用一些服务器的资源，服务器需要维持每一个连接请求的信息，因此过多的连接数意味着服务器的负担很大。\nDos 攻击：DOS(A Denial of Service) 攻击意味着让服务器忙于跟你打交道，以至于他无法跟其他客户端打交道。当其他客户端无法连接，这就是 DOS。\n\nhttp2\n多路复用\n在 HTTP/1.X 中数据是基于文本的有序传输，不能并行传输而且接收端也不知道数据包的顺序。但 HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用: 客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。\n\n并行交错地发送多个请求，请求之间互不影响。\n并行交错地发送多个响应，响应之间互不干扰。\n使用一个连接并行发送多个请求和响应。\n消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间\n\n针对队头阻塞\n\n谷歌在 2008 年发布了 Chrome 浏览器，这种浏览器因其快速和创新而迅速流行。它使谷歌在互联网技术问题上获得了强大的话语权。在 2010 年代初期，谷歌在 Chrome 中增加了对其 Web 协议 SPDY 的支持。\nHTTP/2 标准基于 SPDY，并进行了一些改进\n\nHTTP/2 通过在单个打开的 TCP 连接上多路复用 HTTP 请求，解决了线头阻塞问题\n这允许服务器以任何顺序响应请求，然后客户端可以在接收到响应时重新组合响应，从而在单个连接中加快整个交换的速度。\n\n\n实际上，使用 HTTP/2 服务器甚至可以在请求之前就将资源提供给客户端！举个例子，如果服务器知道客户端很可能需要样式表来显示 HTML 页面，它可以将 CSS“推”到客户端，而无需等待相应的请求。虽然这从理论上讲是有益的，但此功能在实践中很少见，因为它需要服务器了解其服务的 HTML 结构，但这种情况很少发生。\n\nTCP 队头阻塞\n\n\nTCP 的队头阻塞并没有彻底解决： TCP 为了保证可靠传输，有一个“超时重传”机制，丢失的包必须等待重传确认\n\n\nhttp2 虽然很好的解决了 HTTP 队头阻塞的问题。但是 http2 仍然会存在 TCP 队头阻塞的问题，因为 http2 还是基于 TCP 协议  实现的。\nTCP 传输过程中会把数据拆分成一个一个小的有序的数据包，然后经过路由器、集线器、交换机等中间设备转发，最终到达目的地。如果其中某一个数据包没有按序到达，接收端就会保持连接等待数据包返回。这时就会阻塞后续的请求，就造成了 TCP 队头阻塞。\nHTTP/1.1 管道化持久连接也是使得同一个 TCP 连接可以被多个 HTTP 使用，但是 HTTP/1.1 中规定一个域名可以有 6 个 TCP 连接\n而 HTTP/2 中，同一个域名只使用一个 TCP 连接，一旦 HTTP/2 中 TCP 队头阻塞所造成的影响会更大，因为 HTTP/2 的多路复用技术使得多个请求其实是基于同一个 TCP 连接的，如果某一个请求造成了 TCP 队头阻塞，那么多个请求都会受到影响。\n建立连接时间长\n多路复用容易 Timeout： 大批量的请求同时发送，由于 HTTP2 连接内存在多个并行的流，而网络带宽和服务器资源有限，每个流的资源会被稀释，虽然它们开始时间相差更短，但却都可能超时\nhttp3\n针对tcp队头阻塞\nTCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。\nQUIC协议是基于UDP协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。\n针对http2的tcp连接时间长\n前面说到 HTTP2 连接基本上要花到2~3个RTT才能完成连接，但QUIC基本上可以实现1或0RTT去完成连接的。\n如果是首次需要花1RTT去完成连接，但如果非首次连接0RTT就可以完成了，这是因为首次连接时会缓存配置文件，后续再连接时就可以直接使用，从而跳过1RTT，实现0RTT的业务数据交互\n自身特点\n\n实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。\n集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。\n实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。\n\n落地的一些困难\n\n动了底层协议，所以 HTTP/3 的增长会比较缓慢，这和 HTTP/2 有着本质的区别\n\n第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。\n第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。\n第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。\n三个版本在数据传输上的体现\nHTTP/1.1\n\nHTTP/2\n\nQUIC\n\nRTT和RTO\n\nRTT(Round Trip Time)：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值；\nRTO(Retransmission Time Out)：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传, RTO协议实现值最小1s\n\nRTT 和 RTO 的关系是：由于网络波动的不确定性，每个RTT都是动态变化的，所以 RTO 也应随着 RTT 动态变化。\n\n当 RTO &lt; RTT 时, 将会触发大量的重传, 当 RTO &gt; RTT 时候, 如果频繁出现丢包, 重传不及时, 又会造成网络的反应慢, 最好的结果是 RTO 略大于 RTT.\n\n参考\n从 HTTP 到 HTTP/3 的发展简史_文化 &amp; 方法_Scorpil_InfoQ 精选文章\nHTTP/2、HTTP/3的一些新特性及优缺点 - 掘金\n","plink":"https://becase.top/2022/05/26/http协议的发展历程/"},{"title":"关于js中一些看上去简单又不会写的题","date":"2022-05-13T22:08:08.000Z","date_formatted":{"ll":"May 13, 2022","L":"05/13/2022","MM-DD":"05-13"},"updated":"2023-07-11T08:54:19.192Z","content":"x !== x 返回true\n1234const x = ? // Please fill in the value of &quot;x?if (x !== x) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;\n如果你有仔细阅读 es6 的教程的话，就知道这个问题是一个典型的demo\n1234567const x = NaN // Please fill in the value of &quot;x?if (x !== x) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;console.log(NaN === NaN) // falseconsole.log(x !== x) // trueconsole.log(Number.isNaN(x)) // true\n(!isNan(x) &amp;&amp; x !== x) 返回 true\n现在难度提高\n1234const x = ? // Please fill in the value of &quot;x?if(!isNaN(x) &amp;&amp; x !== x) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;\n你知道 Object.defineProperty() 吗？\n请参考Object.defineProperty() - JavaScript | MDN\n123456789window.x = 0 // Any value is OKObject.defineProperty(window, &#x27;x&#x27;, &#123;  get () &#123;    return Math.random()  &#125;&#125;)console.log(x) // 0.12259077808826002console.log(x === x) // falseconsole.log(x !== x) // true\n如何使得 x === x+1\n使用极大值  Number.MAX_SAFE_INTERGER\n参考 Number.MAX_SAFE_INTEGER - JavaScript | MDN\n1234const x =  Number.MAX_SAFE_INTEGER + 1// Please fill in the value of &quot;x?if (x === x + 1) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;\n如何使得 x &gt; x\n使用 Symbol.toPrimitive\n1234567891011const x = &#123; // Please fill in the value of &quot;x?  value: 1,  [ Symbol.toPrimitive ] () &#123;    console.log(&#x27;x&#x27;, this.value)    return --this.value  &#125;&#125;if (x &gt; x) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;\n实现 typeof x === ‘undefined’ &amp;&amp; x.length &gt; 0\n答案是 document.all()\n12345678const x = document.all // Please fill in the value of &quot;x?if(typeof x === &#x27;undefined&#x27; &amp;&amp; x.length &gt; 0) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;console.log(x)console.log(typeof x)console.log(x === undefined)\n参考 javascript - Why is document.all falsy? - Stack Overflow\n","plink":"https://becase.top/2022/05/13/关于js中一些看上去简单又不会写的题/"},{"title":"为Vue组件添加非响应式数据","date":"2022-04-27T21:47:50.000Z","date_formatted":{"ll":"Apr 27, 2022","L":"04/27/2022","MM-DD":"04-27"},"updated":"2023-07-11T08:54:19.192Z","content":"\nvue的数据来源包括 data，computed，自定义options(vm.$options)，实例外(export default外)\n\n在vue组件中data内函数返回的对象默认是响应式的，这种响应式被用在模板更新、watch变更、computed依赖\n此外还有一种场景，数据本身并不需要响应式，多见于 常量 或者一些第三方库，这里就总结下添加非响应式数据的几种方式\n避免把数据挂载到data内函数返回的对象上\n1. 将数据定义在export default之外\n123456const bigData = &#123;  ...&#125;export default &#123;  ...&#125;\n\n不能在模板内使用\n其中一个实例对象的内改变数据，另一个对象内的数据也会被改变\n\n实质是定义在组件这个类上面的，是类的内部变量，被所有实例对象共享\n\n\n\n应用场景：不需要在模板内使用的常量、不变配置项等\n2. 将数据定义在组件的自定义属性中\n1234567891011export default &#123;  ···  bigData: &#123; // 自定义属性    ....  &#125;,  methods: &#123;    doSomething() &#123;      return this.$options.bigData // 访问方式    &#125;  &#125;&#125;\n\n弊端在于数据的定义被分在了2个地方，添加的自定义属性对不了解的人会产生误解，使用时也会增加调用链\n如果数据更改，需要手动调用this.$forceUpdate()才能使模板更新\n\n利用Vue无法检测对象属性的添加来实现\n\n受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的\n\n3. 在created或者mounted中使用 this.bigData\n待实例完成初始化observe后，加入属性\n1234567891011export default &#123;  data() &#123;    return &#123;&#125;  &#125;,  created() &#123;    this.bigData = &#123;      ···    &#125;  &#125;  ···&#125;\n\n同样的，数据的定义被分在了2个地方\n\n剖析observe函数来寻找办法\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122function initData (vm: Component) &#123;  let data = vm.$options.data  data = vm._data = typeof data === &#x27;function&#x27;    ? getData(data, vm)    : data || &#123;&#125;  if (!isPlainObject(data)) &#123;    data = &#123;&#125;    process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(      &#x27;data functions should return an object:\\n&#x27; +      &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;,      vm    )  &#125;  // proxy data on instance  const keys = Object.keys(data)  const props = vm.$options.props  const methods = vm.$options.methods  let i = keys.length  while (i--) &#123;    const key = keys[i]    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;      if (methods &amp;&amp; hasOwn(methods, key)) &#123;        warn(          `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`,          vm        )      &#125;    &#125;    if (props &amp;&amp; hasOwn(props, key)) &#123;      process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(        `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` +        `Use prop default value instead.`,        vm      )    &#125; else if (!isReserved(key)) &#123;      proxy(vm, `_data`, key)    &#125;  &#125;  // observe data  observe(data, true /* asRootData */)&#125;export class Observer &#123;  value: any;  dep: Dep;  vmCount: number; // number of vms that have this object as root $data  constructor (value: any) &#123;    this.value = value    this.dep = new Dep()    this.vmCount = 0    def(value, &#x27;__ob__&#x27;, this)    if (Array.isArray(value)) &#123;      if (hasProto) &#123;        protoAugment(value, arrayMethods)      &#125; else &#123;        copyAugment(value, arrayMethods, arrayKeys)      &#125;      this.observeArray(value)    &#125; else &#123;      this.walk(value)    &#125;  &#125;  /**   * Walk through all properties and convert them into   * getter/setters. This method should only be called when   * value type is Object.   */  walk (obj: Object) &#123;    const keys = Object.keys(obj)  // 切入口2    for (let i = 0; i &lt; keys.length; i++) &#123;      defineReactive(obj, keys[i])    &#125;  &#125;  // 省略&#125;  /** * Define a reactive property on an Object. */export function defineReactive (  obj: Object,  key: string,  val: any,  customSetter?: ?Function,  shallow?: boolean) &#123;  const dep = new Dep()  const property = Object.getOwnPropertyDescriptor(obj, key)  if (property &amp;&amp; property.configurable === false) &#123;  // 切入口3    return  &#125;  // 省略响应式处理代码&#125;/** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. */export function observe (value: any, asRootData: ?boolean): Observer | void &#123;  if (!isObject(value) || value instanceof VNode) &#123;    return  &#125;  let ob: Observer | void  if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123;    ob = value.__ob__  &#125; else if (    shouldObserve &amp;&amp;    !isServerRendering() &amp;&amp;    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;    Object.isExtensible(value) &amp;&amp;  // 切入口1    !value._isVue  ) &#123;    ob = new Observer(value)  &#125;  if (asRootData &amp;&amp; ob) &#123;    ob.vmCount++  &#125;  return ob&#125;\n4. 使用Object.preventExtensions和Object.seal\n\nObject.isExtensible(value)返回为false\n\npreventExtensions\n123456789export default &#123;  data() &#123;    return &#123;      bigData: Object.preventExtensions(&#123;        ···      &#125;)    &#125;  &#125;&#125;\nObject.freeze()\n123456789101112131415161718192021222324let a = &#123; prop: 1, prop2: 2 &#125; // undefinedObject.freeze(a) // &#123;prop: 1, prop2: 2&#125;a.prop = 3 // 3a // &#123;prop: 1, prop2: 2&#125;// Object.freeze()冻结的是值，仍然可以将变量的引用替换掉a = &#123;prop44: 44&#125; // &#123;prop44: 44&#125;a // &#123;prop44: 44&#125;// 注意区分const和Object.freeze// const表示声明常量 不能再赋值 且声明时必须初始化const TEST = 1TEST = 2 // 报错:TypeError: Assignment to constant variable.function deepFreeze (obj) &#123;  let names = Object.getOwnPropertyNames(obj)  names.forEach(name =&gt; &#123;    var property = obj[name]    if (typeof(property) === &#x27;object&#x27; &amp;&amp; property !== null) &#123;      deepFreeze(property)    &#125;    return Object.freeze(property)  &#125;)&#125;\n当bigData值改变时，都需要重新调用一次\n123updateBigData (newBigData) &#123;    this.bigData = Object.preventExtensions(newBigData)  &#125;\n这种写法bigData属性是响应式的，值改变后模板会自动更新；当然如果是bigData某个属性改变，仍然需要手动调用this.$forceUpdate()\n5. 使属性不可枚举\n\n使挂载的数据key不在Object.keys(obj)返回的数组中\n\n1234567891011121314export default &#123;  data() &#123;    const data = &#123;      bigData: &#123;        ···      &#125;      ··· // 其他属性    &#125;    Object.defineProperty(data, &#x27;bigData&#x27;, &#123;      enumerable: false    &#125;)    return data  &#125;&#125;\n整体对比\n\n参考\nObject.freeze() - JavaScript | MDN\nObject.isFrozen() - JavaScript | MDN\nvue性能提升-非响应式数据\n","plink":"https://becase.top/2022/04/27/为Vue组件添加非响应式数据/"},{"title":"vue转react快速上手","date":"2022-04-25T21:52:01.000Z","date_formatted":{"ll":"Apr 25, 2022","L":"04/25/2022","MM-DD":"04-25"},"updated":"2023-07-11T08:54:19.192Z","content":"JSX\n先介绍 React 唯一的一个语法糖：JSX。\n1234&lt;div class=&#x27;box&#x27; id=&#x27;content&#x27;&gt;  &lt;div class=&#x27;title&#x27;&gt;Hello&lt;/div&gt;  &lt;button&gt;Click&lt;/button&gt;&lt;/div&gt;\n上面的 DOM 结构可以看出，要每个标签只有 3 个信息：标签名、属性、子元素，所以上面等同于下面的 JSON 结构：\n12345678910111213141516&#123;  tag: &#x27;div&#x27;,  attrs: &#123; className: &#x27;box&#x27;, id: &#x27;content&#x27;&#125;,  children: [    &#123;      tag: &#x27;div&#x27;,      arrts: &#123; className: &#x27;title&#x27; &#125;,      children: [&#x27;Hello&#x27;]    &#125;,    &#123;      tag: &#x27;button&#x27;,      attrs: null,      children: [&#x27;Click&#x27;]    &#125;  ]&#125;\n当你写下这个 React 组件时：\n12345import React from &#x27;react&#x27;;function MyComponent(props) &#123;    return &lt;div&gt;&#123;props.hello&#125;&lt;/div&gt;&#125;\n最终会被自动工具翻译成：\n12345import React from &#x27;react&#x27;;function MyComponent(props) &#123;    return React.createElement(&#x27;div&#x27;, null, props.hello);&#125;\n理解 JSX 语法并不困难，简单记住一句话，遇到 &#123;&#125; 符号内部解析为 JS 代码，遇到成对的 &lt;&gt; 符号内部解析为 HTML 代码。React 就是通过这个小小语法糖，实现在 JS 里面写 HTML，可能有小伙伴会说 HTML 与 JS 分离不是更好吗？责职分明，混合只会更乱。但当你体验到代码自动提示，自动检查，以及调试时精确定位到一行代码的好处时，就清楚 React 和 Vue 的差距了。\n语法糖转换\n习惯 Vue 的同学都知道很多语法糖，比如 v-if、v-for、v-bind、v-on 等，相比 Vue，React 只有一个语法糖，那就是 jsx/tsx。v-if 这些功能在 React 上都是通过原生 javascript 实现的，慢慢你会发现，其实你学的不是 React，而是 Javascipt，React 赋予你通过 js 完整控制组件的能力，这部分明显比 Vue 的语法糖更加灵活，糖太多容易引来虫子（Bug）。 \nv-if 条件渲染\nvue 中写法是这样：\n123456789101112131415161718&lt;template&gt;  &lt;div&gt;    &lt;h1 v-if=&quot;awesome1&quot;&gt;Vue is awesome!&lt;/h1&gt;    &lt;h1 v-else&gt;else&lt;/h1&gt;    &lt;h1 v-if=&quot;awesome2&quot;&gt;Oh no&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  data: function() &#123;    return &#123;      awesome1: true,      awesome2: false,    &#125;  &#125;&#125;&lt;/script&gt;\n在 React 函数组件中只需这样：\n123456789101112131415import React, &#123; useState &#125; from &#x27;react&#x27;;function Index() &#123;  const [awesome1, setAwesome1] = useState(true);  const [awesome2, setAwesome2] = useState(false);  return (    &lt;div&gt;      &#123;awesome1 ? &lt;h1&gt;React is awesome!&lt;/h1&gt; : &lt;h1&gt;Oh no&lt;/h1&gt;&#125;      &#123;awesome2 &amp;&amp; &lt;h1&gt;React is awesome!&lt;/h1&gt;&#125;    &lt;/div&gt;  );&#125;export default Index;\n只需使用 js 三目运算符语法即可完成条件渲染的功能。或者使用 &amp;&amp; 逻辑，记住下面一句话就能过理解了：\n\n遇到 &#123;&#125; 符号内部解析为 JS 代码，遇到成对的 &lt;&gt; 符号内部解析为 HTML 代码\n\nv-for 列表渲染\nVue 中写法：\n1234567891011121314151617&lt;template&gt;  &lt;ul id=&quot;array-rendering&quot;&gt;    &lt;li v-for=&quot;item in items&quot;&gt;      &#123;&#123; item.message &#125;&#125;    &lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  data() &#123;    return &#123;      items: [&#123; message: &#x27;Foo&#x27; &#125;, &#123; message: &#x27;Bar&#x27; &#125;]    &#125;  &#125;&#125;&lt;/script&gt;\nReact 写法：\n12345678910111213import React, &#123; useState &#125; from &#x27;react&#x27;;function Index() &#123;  const [items, setItems] = useState([&#123; message: &#x27;Foo&#x27; &#125;, &#123; message: &#x27;Bar&#x27; &#125;]);  return (    &lt;ul id=&quot;array-rendering&quot;&gt;      &#123;items.map((item, id) =&gt; &lt;li key=&#123;id&#125;&gt;&#123;item.message&#125;&lt;/li&gt;)&#125;    &lt;/ul&gt;  );&#125;export default Index;\nReact 通过 js 的数组语法 map，将数据对象映射为 DOM 对象。只需学会 js，无需记住各种指令，如果要做列表过滤，直接使用 items.filter(...).map(...) 链式调用即可，语法上更加灵活，如果为了提高渲染性能，使用 useMemo 进行优化即可，类似 Vue 的 computed。\nv-model\nVue 中 v-model 是一个数据绑定语法糖，本质上还是单向数据流，下面的子组件通过 update:title 同步 title 参数。\n123456789101112app.component(&#x27;my-component&#x27;, &#123;  props: &#123;    title: String  &#125;,  emits: [&#x27;update:title&#x27;],  template: `    &lt;input      type=&quot;text&quot;      :value=&quot;title&quot;      @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;&gt;  `&#125;)\nReact 写法较为简单，不需要像 Vue 一样填鸭代码，记住各种规则，所有数据和事件通过 props 传递就行了：\n1234567891011121314import React from &#x27;react&#x27;;interface Props &#123;  title: string;  onUpdateTitle: (title: string) =&gt; void;&#125;function MyComponent(props: Props) &#123;  return &lt;input    type=&#x27;text&#x27;    value=&#123;props.title&#125;    onInput=&#123;e =&gt; props.onUpdateTitle(e.target.value)&#125;  /&gt;&#125;\n更加容易整合 typescript 实现类型推断，需要的逻辑都由 JS 完成，无需记住各种指令、使用方法，参数命名规则。\n事件处理\nVue 中写法\n12345678910111213141516&lt;template&gt;  &lt;div id=&quot;inline-handler&quot;&gt;    &lt;button @click=&quot;say(&#x27;hi&#x27;)&quot;&gt;Say hi&lt;/button&gt;    &lt;button @click=&quot;say(&#x27;what&#x27;)&quot;&gt;Say what&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  methods: &#123;    say(message) &#123;      alert(message)    &#125;  &#125;&#125;&lt;/script&gt;\nReact 写法：\n1234567891011121314import React, &#123; useState &#125; from &#x27;react&#x27;;function Index() &#123;  const onClick = (message) =&gt; () =&gt; alert(message);  return (    &lt;div id=&quot;inline-handler&quot;&gt;      &lt;button onClick=&#123;onClick(&#x27;hi&#x27;)&#125;&gt;Say hi&lt;/button&gt;      &lt;button onClick=&#123;onClick(&#x27;what&#x27;)&#125;&gt;Say what&lt;/button&gt;    &lt;/div&gt;  );&#125;export default Index;\n这里用了函数柯里化，一般事件处理这样就行了：\n12345678910111213import React from &#x27;react&#x27;;function Index() &#123;  const onClick = () =&gt; alert(&#x27;hi&#x27;);  return (    &lt;div id=&quot;inline-handler&quot;&gt;      &lt;button onClick=&#123;onClick&#125;&gt;Say hi&lt;/button&gt;    &lt;/div&gt;  );&#125;export default Index;\n如果需要优化缓存事件处理函数，使用 useCallback 即可。可以看到 Vue 中的事件触发 this.$emit('click') 或者父组件中的代码 v-on=&quot;say('hi')&quot; 都使用了字符串的写法，这样非常不利于类型推断，不利于代码重构。React 的函数写法或者 class 写法都直接使用 js 语法，没有而外的东西，相比 Vue 更容易通过 IDE 进行重构优化。React 中无论方法还是变量，都是采用驼峰命名法，也可以自由定制，Vue 中必须混合小写中隔线、驼峰、字符串组合，不利于统一代码规范。\n插槽\nVue 中写法：\n1234567891011&lt;template&gt;  &lt;button class=&quot;btn-primary&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/button&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  methods: &#123;&#125;&#125;&lt;/script&gt;\nReact 写法：\n1234567891011import React from &#x27;react&#x27;;function Index() &#123;  return (    &lt;button classNames=&quot;btn-primary&quot;&gt;      &#123;props.children&#125;    &lt;/button&gt;  );&#125;export default Index;\nReact 的插槽写法没有 Vue 那么复杂，也没有“备用内容”、“具名插槽”、“渲染作用域”、“作用域插槽”、“动态插槽名”，这些概念和特殊情况的处理，一切通过 JS 逻辑搞定就行了，怎么方便怎么来，比如备用内容的实现：\n123456789101112import React from &#x27;react&#x27;;function Index() &#123;  // 默认情况下使用 Summit 作为按钮文字  return (    &lt;button classNames=&quot;btn-primary&quot;&gt;      &#123;props.children === null ? &#x27;Summit&#x27; : props.children&#125;    &lt;/button&gt;  );&#125;export default Index;\n样式 &amp; 属性\n这部分 Vue 的写法实在是太麻烦了。。。每次我都要查查文档具体怎么用，对象语法、数组语法、内联样式，要记住的有点多，Vue 动态修改样式的写法：\n1234567891011121314151617&lt;template&gt;  &lt;div    class=&quot;static&quot;    :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;  &gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  data() &#123;    return &#123;      isActive: true,      hasError: false    &#125;  &#125;&#125;&lt;/script&gt;\nReact 写法：\n1234567891011121314import React, &#123; useState &#125; from &#x27;react&#x27;;function Index() &#123;  const [isActive, setIsActive] = useState(true);  const [hasError, setHasError] = useState(false);  return (    &lt;div      classNames=&#123;`static $&#123;isActive ? &#x27;active&#x27;:&#x27;&#125; $&#123;hasError? &#x27;text-danger&#x27;:&#x27;&#x27;&#125;`&#125;    &gt;&lt;/div&gt;  );&#125;export default Index;\nReact 里面直接采用 JS 的模板字符串语法，如果样式太多，可以使用 classnames 这个 npm 包，优雅传递各种状态，使用非常简单：\n123456classNames(&#x27;foo&#x27;, &#x27;bar&#x27;); // =&gt; &#x27;foo bar&#x27;classNames(&#x27;foo&#x27;, &#123; bar: true &#125;); // =&gt; &#x27;foo bar&#x27;classNames(&#123; &#x27;foo-bar&#x27;: true &#125;); // =&gt; &#x27;foo-bar&#x27;classNames(&#123; &#x27;foo-bar&#x27;: false &#125;); // =&gt; &#x27;&#x27;classNames(&#123; foo: true &#125;, &#123; bar: true &#125;); // =&gt; &#x27;foo bar&#x27;classNames(&#123; foo: true, bar: true &#125;); // =&gt; &#x27;foo bar&#x27;\n状态管理\nVue 的状态管理官方推荐使用 Vuex 也可采用 Redux。\n\n引用官方文档一段话：\n\n如果你是来自 React 的开发者，可能会对 Vuex 和 Redux 间的差异表示关注，Redux 是 React 生态环境中最流行的 Flux 实现。Redux 事实上无法感知视图层，所以它能够轻松的通过一些简单绑定和 Vue 一起使用。Vuex 区别在于它是一个专门为 Vue 应用所设计。这使得它能够更好地和 Vue 进行整合，同时提供简洁的 API 和更好的开发体验。\n\n这段话其实暴露了 Vuex 的一个缺陷，它和 Vue 强绑定，无法独立存在，这种一些项目升级和迁移时会有很大的麻烦。Redux 作为 React 的状态管理方案之一其实不依赖于 React。\nReact 周边的状态管理方案特别多，如 Redux、Mobx、Recoil 等，各有各的亮点，其中使用最多的应该是 Redux。\n\nRedux 周边生态也很丰富，可以更加下图选择不同的方案：\n\n\nredux-thunk\nredux-promise\nredux-saga\nredux-observable\n\n由于这部分代码较多，不详细写，不过如果你熟悉 Vuex 的概念，转到 Redux 应该不难。Vuex + axios 的做法和 Redux + redux-thunk 的写法类似，不过现在 redux-saga 的方案被更多复杂项目采用，其中很重要的原因是 saga 的概念编写异步代码非常优雅，且能够很好地解决竟态问题（如果采用 Vuex + axios 的写法会异常复杂、冗长），高度定制。\n如果你要迁移 Vue 到 React，建议采用的方案是 Redux + saga，saga 的概念不是那么容易懂，学习需要一些时间，但当你学会的时候就会明白这种写法比直接用 Promise 好太多了。\n生命周期\nVue 的生命周期这里不再重复，查询官方文档即可，React 生命周期如图：\n\n图片可以在这里找到。一般情况下 class 写法主要用到 componentDidMount 和 componentWillUnmount 钩子，React 的函数写法下可以用 useEffect 的执行函数和清理函数去模拟 mount 和 unmount 过程：\n1234567891011121314151617import React, &#123; useRef, useEffect &#125; from &#x27;react&#x27;;function Index() &#123;  const ref = useRef(null);    useEffect(() =&gt; &#123;    console.log(&#x27;mounted&#x27;);    return () =&gt; &#123;      console.log(&#x27;will unmount&#x27;);    &#125;;  &#125;, []);  return &lt;input ref=&#123;ref&#125;/&gt;&#125;export default Index;\nuseEffect 的原理这里不多说，可以看看相关文章：轻松学会 React 钩子：以 useEffect() 为例。其实从 React hook 中可以看到，React 在慢慢淡化生命周期的概念，减少自己对用户代码的侵入，将更多控制权交给用户。\n原生 DOM 操作\n这部分 Vue 和 React 都是采用 ref 写法，Vue：\n12345678910111213141516&lt;template&gt;  &lt;input ref=&quot;input&quot; /&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  methods: &#123;    focusInput() &#123;      this.$refs.input.focus()    &#125;  &#125;,  mounted() &#123;    this.focusInput()  &#125;&#125;&lt;/script&gt;\nReact 写法：\n12345678910111213import React, &#123; useRef, useEffect &#125; from &#x27;react&#x27;;function Index() &#123;  const ref = useRef(null);    useEffect(() =&gt; &#123;    ref.current?.focuse();  &#125;, []);  return &lt;input ref=&#123;ref&#125;/&gt;&#125;export default Index;\nuseEffect 是 React hook，在依赖数组为空的时候效果类似 componentDidMount 的生命周期函数（类似 Vue 的 mounted）。此外 useRef 不止用在这里，也可以挂载一些其他的东东，实现一些复杂操作，比如 previousValue 和对象属性等。\n路由\n大部分项目都是采用 react-router 这个路由方案，定制能力强、API 丰富。\n插件和工具\n浏览器安装 React Develop tools 和 Redux DevTools 两个插件即可。\n","plink":"https://becase.top/2022/04/25/vue转react快速上手/"},{"title":"Redis 快速上手","date":"2021-11-03T00:00:00.000Z","date_formatted":{"ll":"Nov 3, 2021","L":"11/03/2021","MM-DD":"11-03"},"updated":"2023-07-11T08:54:19.192Z","content":"概念\n\nREmote Dictionary Server，key-value 存储系统，是跨平台的非关系型数据库\n\nRedis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-value 数据库，并提供多种语言的 API\n特点\n\n支持数据的持久化\n除了简单的 key-value 类型的数据，同时还提供以下数据结构的存储\n\nlist\nset\nzset\nhash\n\n\n支持数据的备份，即 master-slave 模式的数据备份\n\nzset 数据结构\n有序数据集合：保存一个集合，并为集合中的每个元素分配一个分数（score），相比于普通集合，有序集合中的元素可以根据分数进行排序。\n\n类似于 Set 和 Hash 的复合数据结构\n\n底层使用跳跃表（Skip List）来实现\n—— 跳表 = 多层链表 + 二分查找\n使用场景：\n\n排行榜：得分作为排序的 key\n计数器：数目作为 key\n\n应用场景\n\n缓存：Redis 缓存能够提高应用的响应速度，减轻数据库的压力。\n计数器：Redis 可以用来做计数器，比如网站的 UV，PV 等。\n排行榜：Redis 可以用来做排行榜，比如微博的热门微博排行榜，微信的热门文章排行榜等。\n社交网络：Redis 可以用来做社交网络的好友关系，比如微博的关注，粉丝等。\n消息队列：Redis 可以用来做消息队列，比如秒杀系统中的下单队列，支付队列等。\n分布式锁：Redis 可以用来做分布式锁，比如秒杀系统中的分布式锁。\n分布式 Session：Redis 可以用来做分布式 Session，比如网站的购物车，购物记录等。\n其他：还有很多应用场景，比如：分布式 ID 生成器，分布式任务调度等。\nRedis 的应用场景还在不断的扩展中，比如：Redis 可以用来做分布式任务调度，比如 Celery，Resque 等。\n\n关于社交网络\nRedis 可以通过使用 Sorted Set 数据结构来存储用户之间的好友关系。每个用户都被视为一个元素，而他们之间的关系则通过分数字段进行表示。\n例如，如果用户 A 关注了用户 B，那么可以将 A 的 ID 作为 Sorted Set 中的一个元素，将 B 的 ID 作为另一个元素，然后将 B 的 ID 分配给 A 的元素作为分数字段，这样就可以表示出 A 关注了 B 这个关系。\n同时，还可以使用 Sorted Set 的交集运算和并集运算等功能来实现好友推荐、查找共同好友等高级功能。\n关于消息队列\nRedis 在消息队列（Message Queue）中的应用主要是通过实现 Redis List 来实现的。Redis List 可以看做是一个支持双向插入和删除操作的链表，它可以存储多个字符串元素，并且可以快速地从两端插入或者弹出元素。\n利用 Redis List 的这些特性，我们可以将其作为消息队列的底层数据结构。具体地，当生产者需要发送消息时，它可以将消息写入到 Redis List 的尾部；而消费者则可以从 Redis List 的头部获取消息并进行处理。由于 Redis 的高效读写以及原子操作的支持，可以保证消息队列的高吞吐量和低延迟。\n除了基本的消息传送功能，Redis 还支持一些其他的高级特性，例如：\n\nPub/Sub：Redis 支持发布/订阅模式，它可以让多个客户端同时监听同一个消息频道，并且实时地接收到新发布的消息。\n消息持久化：Redis 提供了多种消息持久化方式，包括 RDB 快照、AOF 日志等，可以确保消息在重启或者故障恢复后不会丢失。\n阻塞式操作：Redis 提供了阻塞式操作，例如 BRPOP 和 BLPOP 命令，可以让消费者在没有消息可处理时自动等待并阻塞，避免了轮询和忙等待的开销。\n\n优缺点\n\n优点：\n\n性能极高 – Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s 。\n丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n原子 – Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行。\n丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。\n\n\n缺点：\n\n单线程 – Redis 的所有操作都是单线程的，这样会导致在高并发的情况下，Redis 会成为性能的瓶颈。\n不支持复杂的查询 – Redis 虽然提供了丰富的数据类型，但是还是不支持复杂的查询。\n数据不是真正的删除，而是被清除 – Redis 删除某个 key 后，会立即释放内存，但是对于大 key 来说，内存释放会比较慢。\n\n\n\n扩展\nRedis 的持久化\n\nRDB：Redis 默认的持久化方式，会在指定的时间间隔内将内存中的数据集快照写入磁盘。\nAOF：Redis 的另一种持久化方式，会将每个收到的写命令追加到文件中，Redis 重启时会重新执行这些命令来恢复数据。\n混合持久化：RDB 和 AOF 两种持久化方式的结合。\n\nRedis 内部的数据结构\n\nRedis 的数据结构主要有三种：简单动态字符串（SDS）、双端链表（deque）、字典（dict）。\nSDS：简单动态字符串，是 Redis 的基本数据结构，是 Redis 的字符串实现。\ndeque：双端链表，是 Redis 的基本数据结构，是 Redis 的列表实现。\ndict：字典，是 Redis 的基本数据结构，是 Redis 的哈希实现\n\nRedis 的主从复制\n主从复制是 Redis 的高可用方案，主从复制的原理是：主节点会将数据同步到从节点，从节点可以是只读的，也可以是可读可写的。\n\n主从复制的优点：\n\n读写分离：主节点负责处理写请求，从节点负责处理读请求，从而实现读写分离。\n高可用：主节点宕机后，从节点会自动提升为主节点，从而实现高可用。\n数据冗余：主从复制可以实现数据冗余，从而实现数据的安全。\n\n\n主从复制的缺点：\n\n主从复制的延迟：主从复制的延迟是主节点写入数据后，从节点才能读到数据的时间差。\n主从复制的数据不一致：主从复制的数据不一致是指主节点和从节点的数据不一致。\n主从复制的故障转移：主从复制的故障转移是指主节点宕机后，从节点提升为主节点的过程\n\n\n\n哨兵模式\n哨兵模式是 Redis 的高可用方案，哨兵模式的原理是：哨兵会监控主节点和从节点的运行状态，当主节点宕机后，哨兵会自动将从节点提升为主节点，从而实现高可用\n","plink":"https://becase.top/2021/11/03/redis/"},{"title":"strapi实践","date":"2021-04-23T11:53:04.000Z","date_formatted":{"ll":"Apr 23, 2021","L":"04/23/2021","MM-DD":"04-23"},"updated":"2023-07-11T08:54:19.192Z","content":"背景\n因为需要一个上传图片的接口，自己又不想为了一个接口专门去开一个后端项目来写，之前有接触过strapi，一直没去深入了解，趁这个机会就学学 strapi\n\nstrapi 是什么？\n一句话总结：一个可以简单、快速、自动生成安全可靠后端 api 的框架，前端开发一大利器\n\n概述\n官网：strapi ，这个名字取自 bootstrap 的后缀 strap，然后因为它是一个提供快速生成安全可靠的 api 架构，然后再加了一个 i，合并就是 strapi，bootstrap 的有启动的意\n使用\n可以先跟着这篇博客简单做个 demo\n——新手入坑：strapi官网教程的简单示例学习\n具体api\n数据库配置\nstrapi在默认下是安装了sqlite数据库，并且默认把数据放在.tmp/data.db中，并且被gitignore了\n官方配置文档：Strapi Developer Docs\n数据库的配置在config/database.js中，这里贴出mysql的配置文件\n——需要在数据库中先创建数据库\n——需要 mysql 的npm包，npm i mysql --save\n12345678910111213141516171819module.exports = (&#123; env &#125;) =&gt; (&#123;  defaultConnection: &#x27;default&#x27;,  connections: &#123;    default: &#123;      connector: &#x27;bookshelf&#x27;,      settings: &#123;        client: &#x27;mysql&#x27;,        host: &#x27;数据库ip地址&#x27;,        port:  3306,        database: &#x27;test&#x27;,        username: &#x27;用户名&#x27;,        password: &#x27;密码&#x27;,      &#125;,      options: &#123;        useNullAsDefault: true,      &#125;,    &#125;,  &#125;,&#125;);\n重启服务后就会发现数据库中多了几张表\n\n同时原先的数据也会消失，因为数据的引用关系已经从 sqlite的db文件转为本地数据库\n\nhttp请求说明\n\n关于通过ajax post/put relation数据的，根据设置一对多/一对一，字段的类型为number[]/number，填入对应数据的id即可\n路由配置\n\n\nmethod 就是请求的方法\npath 请求的路径\nhandler 请求用到的方法，在这里为relation.find，表示会用到在relation文件夹下的controllers/&#123;表名&#125;.js中的find函数。但默认下find函数已经在系统中存在了，所以controllers/&#123;表名&#125;.js中没有find函数\n\n上传图片\n兜兜转转找了很久才发现，并不能直接通过 strapi 的一般方式上传图片，这里的一般方式指的是 （创建实体表——开放权限——发布——接口请求）\n原因——strapi 不支持设置请求头（Content-type）为 multipart/form-data 后发起 POST 请求上传图片\n\n可以看看这个 Issues ：POST multipart/form-data on generated API for file upload · Issue #1316 · strapi/strapi · GitHub\n解决办法：直接使用 strapi 的插件 upload模块\nupload模块位置\n\n\n配置请求头和body参数\n\n\n成功获取到返回数据\n\n项目会在 public/uploads 目录下转存图片，其实你通过 http://[ip]:[port]/upload  访问的图片就是这里的图片，项目本身只是提供了一层映射关系\n参考\nPOST multipart/form-data on generated API for file upload · Issue #1316 · strapi/strapi · GitHub\nstrapi入门\nStrapi Developer Docs\nstrapi的使用\n","thumbnail":"https://cdn.jsdelivr.net/gh/jiechen257/gallery@main/img/202304272135444.png","plink":"https://becase.top/2021/04/23/strapi实践/"},{"title":"Java中的集合","date":"2021-04-17T20:55:40.000Z","date_formatted":{"ll":"Apr 17, 2021","L":"04/17/2021","MM-DD":"04-17"},"updated":"2023-07-11T08:54:19.192Z","content":"记述一下 Java 中的部分相关接口与具体实现类：\n\n具体容器分类\n\n\n非同步集合：在并发访问的时候，是非线程安全的；但是由于它们没有同步策略(加锁机制)，它们的效率更高\n同步集合：对每个方法都进行同步加锁，保证线程安全\n\n\n非同步集合：ArrayList、HashSet、HashMap、LinkedList、TreeSet、TreeMap、PriorityQueue\n同步集合：HashTable、Vector、Stack\n同步包装器 : [ Collections.synchronizedMap(), Collections.synchronizedList() ]\nJava 集合类中非线程安全的集合可以用同步包装器使集合变成线程安全，其实实现原理就是相当于对每个方法加多一层同步锁而已，比如：\n\nHashMap --&gt; Collections.synchronizedMap(new HashMap())\nArrayList --&gt; Collections.synchronizedList(new ArrayList&lt;&gt;())\n\n并发集合：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList、CopyOnWriteArraySet、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque、ConcurrentLinkedQueue\n同步集合类和并发集合类的区别\n不管是同步集合还是并发集合他们都支持线程安全，他们之间主要的区别体现在性能和可扩展性，还有他们如何实现的线程安全。\n同步集合类，Hashtable 和 Vector 还有同步集合包装类，Collections.synchronizedMap()和 Collections.synchronizedList()，相比并发的实现(比如：ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteHashSet)会慢得多。\n造成如此慢的主要原因是锁， 同步集合会把整个 Map 或 List 锁起来，每个操作都是串行的操作，同一时刻只有一个线程能操作。而并发集合不会，并发集合实现线程安全是通过使用先进的和成熟的技术把锁剥离。\n比如 ConcurrentHashMap 会把整个 Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。\nCopyOnWriteArrayList 允许多个线程以非同步的方式读，当有线程写的时候它会将整个 List 复制一个副本给它。如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性\nQueue 接口\nQueue 接口包括 Collection 接口的所有方法。 这是因为 Collection 是 Queue 的超级接口。\nQueue 接口的一些常用方法是：\n\nadd() - 将指定的元素插入队列。如果任务成功，则 add()返回 true，否则将引发异常。\noffer() - 将指定的元素插入队列。如果任务成功，则 offer()返回 true，否则返回 false。\nelement() - 返回队列的开头。如果队列为空，则引发异常。\npeek() - 返回队列的开头。 如果队列为空，则返回 null。\nremove() - 返回并删除队列的头部。如果队列为空，则引发异常。\npoll() - 返回并删除队列的开头。 如果队列为空，则返回 null。\n\nDeque 接口\n在常规队列中，元素是从后面添加的，而从前面删除的。但是，在双端队列中，我们可以从前后插入和删除元素\n\n除了 Queue 接口中可用的方法之外，Deque 界面还包括以下方法：\n\naddFirst() - 在双端队列的开头添加指定的元素。如果双端队列已满，则引发异常。\naddLast() - 在双端队列的末尾添加指定的元素。如果双端队列已满，则引发异常。\nofferFirst() - 在双端队列的开头添加指定的元素。如果双端队列已满，则返回 false。\nofferLast() - 在双端队列的末尾添加指定的元素。如果双端队列已满，则返回 false。\ngetFirst() - 返回双端队列的第一个元素。如果双端队列为空，则引发异常。\ngetLast() - 返回双端队列的最后一个元素。如果双端队列为空，则引发异常。\npeekFirst() - 返回双端队列的第一个元素。如果双端队列为空，则返回 null。\npeekLast() - 返回双端队列的最后一个元素。如果双端队列为空，则返回 null。\nremoveFirst() - 返回并删除双端队列的第一个元素。如果双端队列为空，则引发异常。\nremoveLast() - 返回并删除双端队列的最后一个元素。如果双端队列为空，则引发异常。\npollFirst() - 返回并删除双端队列的第一个元素。如果双端队列为空，则返回 null。\npollLast() - 返回并删除双端队列的最后一个元素。如果双端队列为空，则返回 null。\n\nLinkedList 类\nJava 中的链表具体实现类，对比 ArrayList 的增加和删除的效率更高，而查找和修改的的效率较低\nArrayDeque 类\n实现了 Queue 接口 和 Deque 接口\n\nStack 类\nStack&lt;T&gt; stack = new Stack&lt;&gt;();\n\n\nboolean empty()\n测试堆栈是否为空。\n\n\nObject peek( )\n查看堆栈顶部的对象，但不从堆栈中移除它。\n\n\nObject pop( )\n移除堆栈顶部的对象，并作为此函数的值返回该对象。\n\n\nObject push(Object element)\n把项压入堆栈顶部。\n\n\nint search(Object element)\n返回对象在堆栈中的位置，以 1 为基数。\n\n\n\nJava 集合框架中没有 Stack 接口，仅有 java 早期遗留的一个 Stack 类\n\n因为集成子 Vector，所以 Stack 类是同步的，效率不高，推荐用 ArrayDeque 代替\n\n\n参考\n# java 栈容器_Java 并发技术栈\nJava Queue 接口\n","plink":"https://becase.top/2021/04/17/Java中的集合/"},{"title":"Hello World","date":"2021-03-16T18:15:27.000Z","date_formatted":{"ll":"Mar 16, 2021","L":"03/16/2021","MM-DD":"03-16"},"updated":"2023-07-11T08:54:19.192Z","content":"🌱 Keep learning, hoping to learn unlimited possibilities in a limited time\n","thumbnail":"https://cdn.jsdelivr.net/gh/jiechen257/gallery@main/img/202304281414202.jpeg","plink":"https://becase.top/2021/03/16/hello-world/"},{"title":"关于我","date":"2023-07-11T08:54:19.196Z","date_formatted":{"ll":"Jul 11, 2023","L":"07/11/2023","MM-DD":"07-11"},"updated":"2023-07-11T08:54:19.196Z","content":"\nNot everything that can be counted counts, and not everything that counts can be counted\n\n一句话\n典型的 00 后天秤男🤷‍♂️，base 杭州\n唠叨几句\n首先是一名程序开发人员，其次是 Front-end Engineer（天天被 cue &quot;前端已死&quot;😅），技术栈是 、，目标是 Independent Developer，业余时间主要逛 推特 和 bilibili\nACGM 通吃，moba、桌游通玩 🤖，爱好音乐，目前在玩 🎸，只要有约，立马背上行囊\n厌恶饭圈，杜绝女拳，自由至上，理解万岁！\n一些收录\n点这里\n一些标签\n（👇记得点开小箭头哦…）\n\n  技术向\n   ⌨️ vimer + 双拼，效率至上\n   👻 面对技术栈的选择，一向是都试试\n   👨‍💻 终身学习\n\n\n  ACGM玩家\n   📺 宫崎骏、新海诚、若森数字\n   🎮 top-king，shy sensi\n   🎥 豆瓣 top 250、木鱼水心\n   📖 江南（杨志爬）、意林、刘慈欣\n\n\n  各种玩\n   🪀 密室、蹦极、德州、狼人杀、剧本杀~\n   😋 约饭、旅游（希望人没事） \n\n\n  欲养老而不为\n   😪 想要早睡，可是不困  \n   🌧️ 想要跑步，可是下雨 \n   🌶️ 不能吃辣，被迫达成 \n\n\n  battle\n   🌝 可以理论，但不要恼火\n   🙊 派系分明，理解万岁\n\n\n  小目标\n   🌅 一趟西藏，一趟北欧 \n   🎸 指弹玩家  \n","plink":"https://becase.top/about/"},{"title":"技术之外","date":"2022-03-17T21:53:04.000Z","date_formatted":{"ll":"Mar 17, 2022","L":"03/17/2022","MM-DD":"03-17"},"updated":"2023-07-11T08:54:19.196Z","content":"\n生命好在无意义，才容得下各自赋予意义。假如生命是有意义的，这个意义却不符合我的志趣，那才尴尬狼狈\n\n📜 杂文\n一些思考和理解\n\n2023-03-17 学校-学生-学习\n2021-10-12 消失的附近\n\n📃 随笔\n类似备忘录\n\n2023-06-15 The Boy\n2022-12-15 小阳人的自我修养\n\n📄 摘录\n收集自己在各种论坛上看到有价值的长文或者帖子\n\n2023-05-27 如何听到时间的声音\n2023-02-13 平台的垃圾化\n2022-03-27 大唐三百年\n2021-07-07 语文高考作文可以写负能量吗\n2021-05-05 给青年添个堵\n2021-03-22 生于焦虑，死于自律\n\n🏷️ 清单\n记录下过程，希望自己能一直阅读下去\n\n\n分类\n清单\ntodo\ning\n\n\n\n\n书籍\n书籍清单\nVueJS设计与实现\n设计模式\n\n\n影视\n影视清单\n-\n纸牌屋\n\n\n","plink":"https://becase.top/resources/"},{"title":"工作流 | 实用工具","date":"2023-07-11T08:54:19.196Z","date_formatted":{"ll":"Jul 11, 2023","L":"07/11/2023","MM-DD":"07-11"},"updated":"2023-07-11T08:54:19.196Z","content":"网站\n\n变量命名\nimage generator\nIT book\n壁纸\n在线流程图制作\n前端常用网址总览\n\nIDE\n\nvscode\nwebstorm + IDEA\n\n环境\n\nGit\nMysql + navicat\nNvm + nrm + pnpm\njdk + maven\nredis + redis GUI\npostman + apifox\nfinalshell\n\n文档\n\nObsidian + Vim + 小鹤双拼\ntypora\nsublime text\n\n小插件\n\ntraffic monitor + istatus menu\nsnipaste + paste\nclash\nflux\npicgo\n\n软件\n\n火绒\npotplayer\n\n","plink":"https://becase.top/tools/"},{"title":"学校-学生-学习","date":"2023-03-17T21:53:04.000Z","date_formatted":{"ll":"Mar 17, 2023","L":"03/17/2023","MM-DD":"03-17"},"updated":"2023-07-11T08:54:19.196Z","content":"\n谁又画的出正常和疯狂的分界线，若不是跨过了这条线，又有谁分的清\n\n大学怎么过\n对于刚步入大学的苦逼中学生，都是想要好好过一个有意义且潇洒的大学四年\n想想自己的大学生活，都是尽可能的 潇洒先行，奋斗在后，总是自嘲“玩累了再学”，如果自己心里时刻知道事情的尺度如何，过过这种日子倒也不错\n这里就说下自己心目中的大学四年节奏：\n\n大一多参与社团或者学生会等组织，多认识些人，融入的程度看自己想法（及时止损\n大二多参与竞赛和实验室等活动，开始思考和规划未来，树立目标\n大三朝着明确的目标（考研、就业、考编制等等）开始努力，巴拉巴拉\n大四就结果而言，是否重头再来或者换条赛道，有机会来一次毕业旅行当然更好\n\n就我所学的计算机专业而言，学校的大多课程是枯燥且无意义的，重要的只有那些基础课，掌控好时间和精力上的分配还是很重要的（我一直都是教室倒数三排的常客(:\n技术方向的选型\n作为应用开发人员，大多一开始的技术选型目标都是：\n\n硬件 or 软件\n前端 or 后端\nVue or React &amp;&amp; Java or GoLang\n\n很多人总是把自己拘泥在那一亩三分地中，还没等别人询问便给自己贴上标签 “前端什么垃圾，我选后端”（笑\n大家都是（切图仔 - 前端，crud 工具人 - 后端，sql boy - 运维，调参侠 - 算法）中的一员，技术只有深浅和机遇之分，何来贵贱之别\n首先要明白，我是一个程序开发人员，其次是某某方向的开发。虽然工作可能只会涉及某个方面，但对整体的技术框架都要有所了解。既然如此，每个方向都先浅尝一下也是不错的（就阅读个官方文档和 wiki 的功夫，花不了几天时间\n当建立好宏观上的理论体系后，再决定就某一门进行深入，那就是未来 吃饭 的家伙了\n工具和方法论的重要性\n还是那个程序员的角色，有些人喜欢折腾一些 hacker 一样的工具或者插件，作用要么是用着舒服，要么是效率切实的提高了\n而另外一些人则不理会乃至于不屑去使用这些 toys，他们觉得时间花在实打实的 coding 上更有意义\n这种两极分化的原因一方面是个人性格“偷懒与否”，另一方面是自己平时的圈子影响，我个人是觉得用一些 roi (投入回报比) 高的工具还是很有必要的\n典型的就有：vim 编辑模式\n我自己喜欢去折腾一些工具来打造自己的工作流 —— 通过已有的熟悉的工具乃至 app 来建立一个自己平时工作或者知识积累的办公流程\n例如记知识笔记可以使用 obsidian + vim + picgo + github，包含笔记的编写、文档中图片的图床以及笔记云端存储，这是工作流的一种应用\n还有一个概念是 学习范式，这个术语最开始是在学数据库的时候认识的，后来在一些专业书籍上也频频浏览到，通俗理解就是 学习方法，作为小镇做题家的我们，从一开始就应当开始培养一套属于自己的学习范式，我理解的范式应用逻辑：学习 -&gt; 练习 -&gt; 沉淀 -&gt; 加深学习 -&gt; 继续练习 -&gt; **(循环往复\n工作和生活\n人情世故量力而行，还是多保留一些纯粹的品质吧\n附言\n世界是这样的，没有能力的时候只能先按照现有的规则活下去，然后了解清楚世界的规则之后就利用规则去积累力量，积攒到足够的力量之后就可以最低程度的受到规则的束缚，甚至能够创造新的规则\n","thumbnail":"https://cdn.jsdelivr.net/gh/jiechen257/gallery@main/img/202304281414202.jpeg","plink":"https://becase.top/resources/essays/学校-学生-学习/"},{"title":"消失的附近","date":"2021-10-12T00:00:00.000Z","date_formatted":{"ll":"Oct 12, 2021","L":"10/12/2021","MM-DD":"10-12"},"updated":"2023-07-11T08:54:19.196Z","content":"\n如今的社会，大家对自己周边的世界没有那种要浸淫进去，形成一个叙述的愿望或能力\n\n01 现状\n你在与人交谈的时候是否有一种感觉，现在人们讨论的都是一些仰望不可及的远边，或是建政圈子里的国家大事，或是某某明星的塌房事件\n这些事情的发生与否与自己毫无关联，事件结果对自己也毫无影响，但因为大家都在讨论这样的话题，自己如果什么也不知道，就像是一个局外人\n久而久之，大家的话题开始愈发的遥不可及，换句话说，他们的“附近”正在逐渐消失\n02 背后的原因\n自从互联网开始大数据杀熟之后，人们在荧幕中看到的都是一个个信息茧房中筛选出来的\n\n“时间抹杀了空间”，我们的耐心只有3秒，疏离和退避在我们中间深化\n\n“每个个体与另一个个体都通过那个高度抽象的系统来协调”，我们对悬浮于我们之上那个系统高度信任，但回到家，紧闭大门，我们却对身边的邻居没有丝毫的了解\n——公共领域其实在塌陷，网络让公共领域看似延展到整个地球，实际上是缩小到宅在家里——这是一种虚幻的镜像，犹如小小的胶片通过灯光投放到大屏幕上一样，可人只有在与他人的相处之中之中才能确立自己的世界。\n地理意义的“附近”已经转化为数字意义的“附近”。市场是“附近”消失的重要原因。\n选择被精心设计，最后导致了同质化的抑郁；意义被经济逻辑侵蚀，被锻造成广泛的消费样态。自由主义市场的基本观点为资源是必须自由流动的，交易是不应存在障碍的\n——资本叠加技术，对“即时性”的追求正在不断压缩“附近”的空间，但“附近”并非消失而是存在于美团、支付宝、滴滴的各种算法背后，人与人的真实的关系变成了精准计算后的各种“推送”\n即时让人对时间的变化感受更加强烈。“中间”消失了。 “附近”消失了\n03 如何应对\n感受当下，活在当下\n如果觉得抽象理解不了，那你可以读读下面的诗句\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647记得早先少年时Remember the old days大家诚诚恳恳when everyone was sincere说一句 是一句one&#x27;s word is one&#x27;s bond清早上火车站The dawn of the train station长街黑暗无行人the dark street with no sign of pedestrian卖豆浆的小店冒着热气and the steam from the soy-milk stall从前的日色变得慢The nightfalls used to come late in the past车，马，邮件都慢Everything was slow, the bike, the horse, and the post一生只够爱一个人a lifetime was all but enough to be in love with one从前的锁也好看The old-school lock was beautiful钥匙精美有样子and the key exquisite looking你锁了 人家就懂了once locked, the others understood","plink":"https://becase.top/resources/essays/消失的附近/"},{"title":"大唐三百年","date":"2023-07-11T08:54:19.196Z","date_formatted":{"ll":"Jul 11, 2023","L":"07/11/2023","MM-DD":"07-11"},"updated":"2023-07-11T08:54:19.196Z","content":"\n因为这个场景，对这个词影响深刻 视频链接\n\n依山傍水房数间，行也安然，坐也安然。\n一头耕牛半顷田，收也凭天，荒也凭天。\n雨过天晴驾小船，鱼在一边，酒在一边。\n路逢骚客问诗篇，好也几言，歹也几言。\n布衣得暖胜丝棉，新也可穿，旧也可穿。\n粗茶淡饭饱三餐，早也香甜，晚也香甜。\n夜归妻子话灯前，今也谈谈，古也谈谈。\n一觉睡到日三竿，不是神仙，胜似神仙！\n\n\n《闲居即兴》作者：萧锦忠\n\n","plink":"https://becase.top/resources/excerpt/大唐三百年/"},{"title":"如何听到时间的声音","date":"2023-07-11T08:54:19.196Z","date_formatted":{"ll":"Jul 11, 2023","L":"07/11/2023","MM-DD":"07-11"},"updated":"2023-07-11T08:54:19.196Z","content":"“我怎么叫呀？叫妈妈，对啦！”\n“怎么又拉一裤兜子！孩他爹，屎裤子拿一下！”\n“自行车让你爸教你！让他带着你骑！”\n“饭盒别忘了带！给你做了青椒面！哎呦，水瓶哪儿去了？”\n“又没及格？你还敢学我签字儿啊你！”\n“吃点橘子！吃点排骨！吃点青椒别老吃面！”\n“中考能考好，我就把电脑给你买了！”\n“怎么又打架？我看看，哎呦…”\n“妈给你报了个班，你看看去呗？”\n“大学别考北京了，那里太远，妈不放心！”\n“钱带的够吗？北京食堂卖青椒面不？”\n“一年你才回来一趟，不是寒假吗？怎么才十天呀……”\n“学校工作分配吗？妈也给你找了个公务员的班，就在咱们镇口！可好啦！”\n“那领导对你满意吗？没挑你刺吧，安全吗？北京地铁人多不多？”\n“升职啦！哎呦，哎呦，真好，真好，真好。”\n“你看看你过年也没回来，还不让唠叨几句！”\n“哪里认识的对象呀，那边家里是独苗吗？家长人咋样？”\n“你现在要孩子，你妈还没老，还能帮你带带。”\n“家里还有些钱，能给你凑个首付，买好的，买好的。”\n“你爸爸他……”\n“你多给妈打些电话，妈家里一个人待着，闷。”\n“过年还回来吗？带着娘俩来家里，妈给你做青椒面。”\n“妈能去北京看看你吗？过几年走不动啦。”\n“你回来啦，推轮椅带你妈出去转转……”\n“他们家卖青椒的也走了，妈每年底都收一捆，你没回，那椒一年就坏一捆。”\n“你说时间怎么过这么快呢，一转眼，你都这么大了……”\n“……”\n“…… 我怎么叫呀？叫爸爸，对啦……”\n\n你会继承某一个人的时间 在这条无边无垠的长河里继续流淌下去\n\n\n转载自：如何听到时间的声音\n\n","plink":"https://becase.top/resources/excerpt/如何听到时间的声音/"},{"title":"平台的垃圾化","date":"2023-07-11T08:54:19.196Z","date_formatted":{"ll":"Jul 11, 2023","L":"07/11/2023","MM-DD":"07-11"},"updated":"2023-07-11T08:54:19.196Z","content":"\n平台是这么死掉的：一开始它们对用户很好；然后它们滥用用户来讨好自己的商业客户；最后，它们滥用这些商业客户，把所有的价值都追讨回来。接着，它们就完蛋了。\n我称之为“enshittification”（垃圾化），这是个看似不可避免的结果，因为改变平台对价值的分配方式很容易，再加上“双边市场”的性质，平台位于买家和卖家之间，可以劫持一方作为另一方的人质，从而抽取在二者间传递的价值，而且份额越来越大。\n一个平台起步的时候需要用户，所以它要让自己显得对用户有价值。不妨看看亚马逊：多年来，它一直处在亏损状态，利用其接触资本市场的渠道来补贴你购买的一切。它以低于成本的价格出售商品，并以低于成本的价格给你运输东西。它运营着干净且有用的搜索。如果你搜索一件产品，亚马逊会尽最大努力把它放在搜索结果的顶部。\n这对于亚马逊的客户来说是笔划算的交易。我们当中的很多人都蜂拥而至，以致许多实体零售商都倒闭死亡，很难有活路。亚马逊卖电子书和有声读物给我们，但这些电子书和有声读物是通过 DRM 永久锁定在它的平台上的，因此如果我们删除亚马逊及其 app 的话，我们在媒体上花费的每一块钱都是我们被迫放弃的一块钱。亚马逊向我们出售 Prime，让我们预付一年的运费。Prime 客户会从亚马逊开始自己的购物，在 90% 的时间内，他们都不会跑到其他任何地方去搜索商品。\n这吸引了许多商业客户——将亚马逊变成它从一开始就承诺要成为的“万货商店”（everything store）的交易市场卖家。随着这些卖家的涌入，亚马逊的补贴对象变成了供应商。Kindle 和 Audible 的创作者拿到了丰厚的报酬。交易市场卖家能接触到大量受众，亚马逊只向他们收取很低的佣金。\n这种策略意味着购物者想要在亚马逊以外的任何地方找到东西会变得越来越难，而这又意味着他们只能在亚马逊上搜索，进而意味着卖家必须在亚马逊上面卖东西。这时候，亚马逊开始把从自己的商业客户那里收获的盈余转给亚马逊股东。现如今，Amazon Marketplace 卖家的售价里面有超过 45% 是交给亚马逊的各种杂七杂八的费用（junk fees）。亚马逊耗资 310 亿美元打造的“广告”计划，实际上是一个让卖家相互竞争的付费计划，迫使他们为了争取成为你搜索的首选而互相抬价。\n如今搜索亚马逊不会生成与你的搜索最匹配的产品列表，它显示的是这样一个产品清单，那些产品之所以出现在上面，是因为卖家出的钱最多，所以可以占据搜索的顶部位置。但这些费用也包含进你为产品支付的成本之中了，而亚马逊对卖家给予的“最惠国待遇”要求意味着他们不能在其他地方以更便宜的价格卖自己的商品，这样一来亚马逊就把每一家零售商的价格都抬高了。\n在亚马逊上搜索“猫床”，第一页的屏幕全都是广告，其中就包括亚马逊山寨产品的广告，导致其他卖家被赶出市场（第三方必须向亚马逊支付 45% 的“苛捐杂税”，但亚马逊不会对自己收取这些）。总而言之，“猫床”搜索结果的前五页屏幕有 50% 都是广告。\n这就是 enshittification（垃圾化）：盈余先是返还给用户；然后，一旦用户被锁定住，盈余就会流向供应商；然后一旦供应商也被锁定了，盈余就会交给股东，而平台就会变成一坨没用的垃圾。从移动应用商店到 Steam，从 Facebook 到 Twitter，都是这么一个垃圾化（enshittification）的生命周期。\n就像 Cat Valente 圣诞前写的那篇权威大作描述的那样，这就是为什么像 Prodigy 这样的平台会在一夜之间摇身一变，从一个你去社交的地方，变成了一个对你的期望是“停止互相交谈，并开始买东西的地方”。\n这种盈余的骗局就是发生在 Facebook 身上的事情。一开始，Facebook 对你很好：它向你展示了你热爱与关心之人必须要说的话。这造成了一种相互劫持的局面：一旦你关心的人在 Facebook 上达到了临界数量，实际上你就不可能离开那里了，因为你必须说服他们所有人也离开那里，并就去哪里达成一致。你可能爱你的朋友，但如果有一半的时间你们都不能就看什么电影和去哪里吃晚饭达成一致的话，那就算了吧。\n然后，它开始往你的动态消息里面硬塞你根本都没关注的帐户的帖子。一开始，是媒体公司的帖子，这是 Facebook 给用户优选的精神食粮，好让他们点击文章并把流量返给报纸、杂志和博客。然后，一旦这些发行商依赖起 Facebook 的流量，它就开始减少流量。一开始，它的对象是那些用 Facebook 来展示带有自己网站链接的摘录的发行商，Facebook 切断了它们的流量，以此作为推动发行商在 Facebook 的围墙花园内提供全文动态消息的一种手段。\n这导致发行商只能完全依赖于 Facebook——他们的读者不再访问发行商的网站，他们只在 Facebook 上关注它们。发行商被那些读者挟持了，而读者又互相挟持了。然后，Facebook 不再向读者显示出版商的文章，调整 The Algorithm（算法）来抑制发行商的帖子，除非他们交钱给 Facebook、面向明确订阅了自己的读者“boost”（推广）他们的文章，并要求 Facebook 将它们放进他们的动态消息里。\n现在，Facebook 开始往动态消息里面塞进更多的广告，把你想看到的人的内容和想占据你眼球的陌生人的广告混在一起。它给了那些广告商很划算的买卖，只收取微薄的费用，让他们根据从你那里窃取的个人数据档案来发送定向广告。\n卖家对 Facebook 也开始形成依赖，因为如果无法访问那些定向推销的话，他们就无法开展业务。这时候 Facebook 开始暗示要抬高广告价格，不再担心广告欺诈，并与谷歌勾结一气，通过名为 Jedi Blue 的非法程序操纵广告市场。\n时至今日，Facebook 已经完全被垃圾化了，不管你是用户、媒体公司还是广告商，这个地方都很糟糕。这是一家故意对很大一部分发行商进行“拆家”的公司（那可是 Facebook 的依靠啊），用一则视频在 Facebook 用户当中很受欢迎的虚假声明，欺骗那些公司 “向视频转型”。结果在投入了数十亿美元之后，而受众从未变现，媒体机构一批批地倒闭。\n但 Facebook 现在有了一个新的推销手段。它声称这个东西叫做 Meta，这个东西要求我们在余下的日子里，用不长腿、没有性、受到严密监视的低多边形卡通人物的身份活着。它已向为这个元宇宙制作 app 的公司许诺，它不会像对待旧日 Facebook 上的发行商那样对待他们。有没有人为此买账还有待观察。正如马克·扎克伯格曾经向一位同行坦承的那样，他对所有那些将个人信息发到他的新网站“TheFacebook”的哈佛同学感到惊讶：\n\n我不知道为什么。\n他们“相信我”\n一群蠢货。\n\n一旦你了解了这种垃圾化的模式，许多平台之谜就会自行解决。想想 SEO 市场，或者一整个活跃的，花费了无数时间研究无用的平台克里姆林宫学（Kremlinology）的在线创作者世界，他们一门心思想要发现那一根根算法的绊线，因为碰到那根绊线的话，他们投入了金钱、时间和精力创作出来的作品就会失败。\n为平台工作就像给老板打工，他会因为你违反了各项规则而从你的每一笔薪水里面扣钱，但他不会告诉你这些规则是什么，因为如果他告诉你规则的话，你就会知道如何在他不注意和不扣你工资的情况下违反这些规则。内容审核是唯一将隐蔽性视为安全最佳实践的领域。\n现在的形势已经非常严峻，以至于像 Tracking Exposed 这样的组织开始招募一支人类志愿者大军以及一支由无头浏览器组成的机器人大军，试图解开The Algorithm（算法）这台随心所欲的机器判决背后的逻辑，这既是为了让用户可以选择去调整他们收到的推荐，也是为了帮助创作者避免因为秘密屏蔽而导致工资被盗。\n但是，如果根本就没有底层逻辑该怎么办？或者，更重要的是，如果这种底层逻辑会根据平台的优先级而发生变化该怎么办？在你去赶集的途中，你也许会发现一些可怜的傻瓜整天带着一只巨大的泰迪熊走来走去，那是他们投篮中了三个球赢得的。\n这个投篮游戏被操纵了。巡回演艺团的人可以用一个隐藏开关让球弹出篮筐。除非他们希望你赢，否则没人能赢得一只大泰迪熊玩偶。为什么游乐场的人会让傻瓜赢得一个大泰迪熊？这样傻瓜就可以整天带着它，说服其他傻瓜掏出五美元，来获得赢得一个大泰迪熊的机会。\n这个巡回演艺团给那个可怜的傻瓜分了一个大泰迪熊，就像平台将盈余分给关键的表演者一样——他们是一个“大商店”骗局的说服者，是吸引来给平台创作内容的其他傻瓜的手段，从而把他们自己和他们的受众都给拴住。\n这让我想到了 TikTok。TikTok 有很多面，“为靠手机生活的青少年提供的免费的 Adobe Premiere”是其中之一。但它在早期之所以如此成功，是因为推荐系统的强大。从一开始，TikTok 就非常非常擅长向用户推荐内容。好得出奇。\n通过为它认为用户会喜欢的东西做出诚挚推荐，TikTok 建立了一个庞大的受众群体，比很多人想象的都要大——鉴于竞争对手像 YouTube、Instagram 等把用户拽得这么紧。现在 TikTok 有了受众，它正在夯实自己的收益，并试图挖走那些仍然顽固地抓住 YouTube 和 Insta 不放的媒体公司和创作者。\n前段时间，《福布斯》的 Emily Baker-White 对 TikTok 的母公司字节跳动来了一次精彩爆料，让我们得以窥见其内部实际的运作方式，文章揭露了 TikTok 员工会用“预热工具”（heating tool）把特定账号的视频推送到数百万受众的动态消息里面。\n这些视频会进入到 TikTok 用户的 For You（推荐页面）动态消息上， TikTok 称这些视频是“算法根据你在 app 的行为预测你的兴趣进行排名的”。实际上，For You 只是有时候由 TikTok 认为会给你的体验增加价值的视频组成——其余时候都是 TikTok 植入的视频，目的是让创作者认为 TikTok 是个接触受众的好地方。\n\n“消息人士告诉《福布斯》，TikTok 经常利用预热工具来吸引网红和品牌，通过夸大视频的观看次数来吸引他们建立合作伙伴关系。这表明预热可能会让部分网红和品牌受益——这是 TikTok 寻求与之建立商业关系的人——与之没有商业关系的则成为代价。”\n\n换句话说，TikTok 正在分发大泰迪熊。\n但 TikTok 并不从事赠送大泰迪熊的业务。尽管 TikTok 是个起源于中国的经济体，但它不过是又一个将人类视为不便的肠道菌群的人工有机体罢了，其目的还是回形针最大化（编者注：一个关于人工智能反乌托邦的隐喻，如果人工智能的目标是实现回形针产量的最大化的话，最终整个宇宙都会变成回形针的天下）。TikTok 只会将免费注意力引导到它想要诱捕的人身上，等到他们掉进了陷阱，它就会收回这种注意力，并开始将其货币化。\n“货币化”这个词很糟糕，它默认了不存在所谓的“注意力经济”。你不能将注意力用作交换媒介。你不能将其用作价值存储。你不能把它当作记帐单位。注意力就像加密货币：一种毫无价值的代币，只有在你可以欺骗或胁迫某人放弃“法定”货币来换取它时才有价值。你必须把它“货币化”——也就是说，你必须用假钱换真钱。\n就加密货币而言，其主要的货币化策略建立在欺骗的基础上。交易所和“项目”分发了一大堆的大泰迪熊，从而打造出一支由忠实信徒犹大山羊（注：Judas goats，畜牧员在圈养山羊时，会专门训练一只强壮的山羊为领头羊，利用山羊的从众跟随特性，在将要进行屠宰时，会事先通过给领头羊好处，利用它诱骗其他山羊进入屠宰场，而后畜牧员让犹大山羊溜之大吉）组成的军队，去说服同行者把钱交给他们，然后试着投中一些球进篮筐。\n但欺骗能产生的“流动性供应”只有那么多。最终，傻瓜会被你用完。要让很多人尝试投篮，你需要的是胁迫，而不是说服。想想看，美国公司是如何停掉保证你有尊严地退休的固定福利养老金，而用市场化的 401（k）养老金取而代之的，你被迫将积蓄押在被操纵的赌场上，这样你就变成了赌桌上的傻瓜，等着被人收割。\n早期加密货币的流动性来自勒索软件。一群绝望、惊慌失措的公司和个人的数据被犯罪分子窃取，这为加密货币的流动性建立了基准，因为他们只能通过用真钱换取加密货币假钱来取回数据。\n加密货币胁迫的下一阶段是 Web3：web 被弄成一系列的收费站，你只能靠用真钱换取加密货币假钱才能通行。互联网是必需品，而不是锦上添花，它是充分参与就业、教育、家庭生活、健康、政治、公民甚至浪漫的先决条件。通过持有所有这些东西去赎回加密收费站后面的东西，持有人希望将他们的代币兑换成真金白银。\n对于 TikTok 来说，“预热”持怀疑态度的表演者与媒体公司发布的视频是一种手段，免费发放泰迪熊是将他们变成忠实信徒的一种手段，这样这些信徒就会把所有的筹码都推到桌子中间，放弃他们在其他平台上建立受众群体的努力（TikTok 的格式与众不同也起到了帮助作用，这样就很难把视频重新用于在 TikTok 的竞争对手平台上传播）。\n一旦这些表演者和媒体公司被迷住后，就进入下一阶段：TikTok 会撤回“预热”，不再把他们的视频贴到从未听说过他们、也没有对看看他们的视频提出请求的人面前。TikTok 在这里表演的是一种很微妙的舞蹈：用户的动态消息上他们能折腾的垃圾化（enshittification）就只有这么多，而且 TikTok 上面还有很多其他的表演者是他们想派发大泰迪熊的。\nTikTok 不仅会通过算法降低表演者的优先级来剥夺赋予他们的“免费”注意力，还会通过“投递视频给订户失败”来主动惩罚他们。毕竟，每当 TikTok 给你看了你要求看的视频时，它就失去了给你看它想让你看的视频的机会，因为你的注意力是一个大泰迪熊，它也可以把它送给它正在追求的表演者。\n这正是 Twitter 在向垃圾化（enshittification）迈进的过程中的所为：由于它的“货币化”的改变，大多数关注你的人将永远也看不到你发布的内容。我在 Twitter 上面大概有 50 万粉丝，我的帖子过去的阅读量经常都有数十万甚至数百万。而今天，这个数字只有几百，或几千。\n我刚刚淘了 8 美元给 Twitter，为了换取 Twitter Blue 的资格，因为这家公司给我发出了强烈暗示：如果我支付赎金的话，它只会向提出要求的人展示我发布的内容。这是互联网上酝酿时间最长的战争之一的最新战役：一场争夺端到端的战斗。\n刚开始的时候，是 Bellheads 与 Netheads 之争。Bellheads派为大型电信公司效力，他们认为网络的一切价值理所当然属于运营商。如果有人发明了一项新功能（比方说，来电显示），则只能以让运营商每月向你收取使用费的方式推出。这就是软件即服务，贝尔大妈（Ma Bell）风格的 SaaS。\n而 Netheads 派则认为价值应该转移给网络的边缘——应该是分散的、多元化的。从理论上来说，Compuserve 本来也可以实现自己版本的来电显示“货币化”（编者注：来电显示这项收费业务让你可以在接听前知道对方是谁），通过让你额外支付 2.99 美元，然后就可以在打开邮件之前看看电子邮件的“发件人”是谁，但是他们没有这么做。\nNetheads 希望建立起多样化的网络，上面应该有很多产品和服务，有大量竞争，并且切换到不同竞争对手之间应该是很轻松、成本很低的（因为具备互操作性）。有的之所以想要这样的网络，是因为他们相信有朝一日这张网会编织进这个世界，他们不想生活在一个由寻租的地主主导的世界里。有的则坚信市场竞争是创新的源泉。有的是这两样都信。不管是哪一种，他们都看到了网络捕获（network capture）的风险，看到靠诡计和胁迫实现货币化的驱动力，他们想阻止这种风险，遏制这种动机。\n他们构思了端到端的原则：即网络的设计理念应该是让愿意发言的人的消息尽可能快速可靠地传递到愿意收听的人的端结点。也就是说，不管网络运营商能不能通过向你发送想要接收的数据来赚钱，它的职责都是为你提供你想要查看的数据。\n在今天的服务层上，端到端原则已经寿终正寝。右翼那些有用的白痴被骗了，他们认为 Twitter 管理不善的风险是“唤醒了秘密屏蔽（shadowbanning，影子禁令，限流）”，也就是你讲的话不会发给要求听到它们的人，因为 Twitter 的深层机构（deep state）不喜欢你的意见。当然了，真正的风险是你说的话不会发给要求听的人，因为 Twitter 可以通过让他们的动态消息垃圾化（enshittification），然后向你收赎金换取获得（你的话）被纳入其中的特权，从而赚取更多的钱。\n正如我在本文开头所说的那样，垃圾化（enshittification）对平台资本主义施加了近乎不可抗拒的引力。把垃圾化（enshittification）的拨盘调到 11 太容易了。Twitter 把大部分的技术熟练工都解雇掉，仍然可以一直在转动拨号盘，即便拨动的是一群绝望、士气低落，拿着 H1B 的员工，因为面临被驱逐出境的威胁，他们已经被绑在 Twitter 这艘正在沉没的船上。\n垃圾化的诱惑还被互操作性的阻碍放大：当 Twitter 禁止可互操作的客户端、弱化（nerfs，最早指在游戏中，游戏开发或运营商在游戏版本更新时对于游戏的某些游戏内容进行削弱的调整行为）它的 API、并定期通过暂停账号来恐吓把自己的 Mastodon 账号放到个人档案的用户时，离开 Twitter 变得难上加难，从而增加了可以强制喂消息而无拂袖而去风险的垃圾化用户的数量。\nTwitter 不会变成一个“协议”。像 Bluesky 这样的项目在这个平台上没人会真的买账，我敢打赌，因为如果实施了 Bluesky（Twitter 的去中心化社交媒体协议），并且 Twitter 用户可以订购自己的动态消息，以便实现垃圾化（enshittification）的最小化，并在不牺牲自己的社交网络的情况下离开该服务的话，Twitter 大部分的“货币化”策略就要失效了。\n只有在适度的情况下，垃圾化（enshittification）策略才会成功。即使是被锁定得最牢的用户最终也会突破爆发点而走开，或者被推开。正如《屋顶上的小提琴手》（Fiddler on the Roof）中，安那特夫卡（Anatevka）的村民在最终被迫逃往克拉科夫、纽约和芝加哥之前，已经忍受了哥萨克人的暴力袭击和大屠杀多年。\n对于那些已经被垃圾化搞得一团糟的公司来说，这种适度是很难达到的。个别产品经理、高管以及激进股东往往都愿意以牺牲可持续性为代价来获得快速回报，并且个个都争先恐后，看谁能先吃掉他们的谷种。垃圾化（Enshittification）只能持续这么久，因为互联网已经退化成“五个巨型网站，而且每个网站上都充斥着其他四个网站的屏幕截图。”\n随着（碎片化的）市场被一群互相勾结的垄断者缝合，不会突然冒出更好的选择并引诱我们离开了，如果确实出现了这种情况的话，垄断者就会干脆把对方买下，并将其整合到垃圾化（enshittification）策略之中，就像马克·扎克伯格注意到大量出走的 Facebook 用户原来是跑到了 Instagram 上面之后，于是他就收购了 Instagram。正如扎克伯格所说的那样，“与其竞争，不如收购”。\n这是 Amazon Smile 兴衰背后隐藏的动态，当你在那里购物时，亚马逊会向你选定的慈善机构捐赠少量资金，但前提是你用亚马逊自己的搜索工具找到你要买的产品。这让亚马逊客户有动力去使用其自身日益垃圾化的搜索，里面也许塞满了被迫支付贿赂的卖家的产品，以及它自己的山寨产品。另一种办法是用谷歌，它的搜索工具会直接引导你渠去到要找的产品，然后向亚马逊收取把你送到它那里去的佣金。\nAmazon Smile 的关闭恰逢 Google Search（谷歌搜索）的日益垃圾化，后者是谷歌内部开发出来的唯一一款成功产品。它所有其他的成功产品都是从其他公司买来的：视频、文档、云计算、广告、移动等都是买来的，而它自己的产品要么像 Google Video 一样砰然倒下，要么是山寨别人的（Gmail 是 Hotmail 的克隆），或者改编自其他公司的产品，如 Chrome。\nGoogle Search 的开发原则是创始人拉里·佩奇（Larry Page）与谢尔盖·布林（Sergey Brin）制定的。他们在 1998 年的那篇具有里程碑意义的论文《大规模超文本网络搜索引擎剖析》中对此进行了阐述：“广告资助的搜索引擎内在地会偏向广告商而远离消费者的需求。”\n即便对垃圾化（enshittification）具备了根本理解，谷歌也无法抗拒它的塞壬之歌。今天的谷歌搜索结果是一个越来越无用的泥潭，里面充斥着指向其自家产品的链接、不够好没法靠自己爬到搜索结果头部的产品广告，以及寄生在前者身上的 SEO 垃圾。\n垃圾化很有杀伤力。谷歌刚刚裁掉了 12000 名员工，出于对“AI”聊天机器人兴起陷入的全面“恐慌” ，谷歌正在全力打造一款 AI 驱动的搜索工具——也就是一款不会向你展示你要求的内容，而是它认为你应该看到的内容的搜索工具。\n现在，你可以想象这样一个工具会给出很好的推荐，就像 TikTok“垃圾化”之前的算法所做的那样。但鉴于产品经理、高管和股东有强烈的动机将结果垃圾化到这样一个精确的阈值，就是让用户生气到几乎想要离开，但又不是很决绝的程度，你很难看出谷歌怎么才能设计出一个非垃圾化的搜索聊天机器人前端。\n即使它设法解决了这个问题，这种几乎没用但又不是一点用都没有的平衡也是十分脆弱的。任何的外来冲击——像 TikTok 这样穿透大型科技公司的反竞争“护城河和围墙”的新生竞争对手、隐私丑闻、员工造反等——都可能令其陷入剧烈震荡。\n垃圾化（Enshittification）确实是平台的灭亡之道。其实这没什么。我们不需要互联网有永恒的统治者。出现新的想法和新的工作方式是可以的。立法的和政策制定者的重点不应该是延缓垂死平台的暮年垂老。相反，我们的政策重点应该是在这些公司到期时最大限度地降低用户的成本：像端到端这样的权利意味着不管僵尸平台的自噬性变得有多强，愿意发声的和愿意倾听的仍然可以彼此相连。\n政策制定者应该关注退出的自由——用户要有离开正在沉没的平台，同时继续与离开的社区保持联系、享受所购买的媒体和app，并保留所创建的数据的权利。\nNetheads 派是对的：技术自决与科技企业的自然要求不一致。当他们剥夺我们的自由——我们说话、离开、联系的自由时，他们可以赚更多的钱。\n多年来，即便是 TikTok 的批评者也不得不承认，不管怎么说，它确实很擅长猜测你想看什么。但 TikTok 无法抗拒这种诱惑：向你展示它想让你看的而不是你想看的。垃圾化已经开始（enshittification），而且现在已不大可能停止。\n\n\n转载自：平台的垃圾化\n\n","plink":"https://becase.top/resources/excerpt/平台的垃圾化/"},{"title":"生于焦虑，死于自律","date":"2021-02-22T00:00:00.000Z","date_formatted":{"ll":"Feb 22, 2021","L":"02/22/2021","MM-DD":"02-22"},"updated":"2023-07-11T08:54:19.196Z","content":"2020年。\n我听了很多逆袭故事，看了很多学习方法，知道了好多能让我自律的技巧。\n我听的故事，给我震撼，激我共鸣，与我共情，多少次，我幡然醒悟，大梦初醒，热血沸腾，让我又有了莫大的勇气去面对现实，也给我了短暂的慰藉，告诉我亡羊补牢，为时未晚。\n我看的方法，教会我目标规划，精力管理，要我高效记忆，要我极度自律，跟我讲复盘总结的重要性，告诉我深度思考的紧迫性，警醒我碎片信息的危害性。\n底层原理，系统优化，流程拆分。一个个名词把我的学习观打得稀碎。\n我只能，卧槽，牛逼。\n如获至宝，当之如救命稻草。\n但是，多少次，午夜梦回。\n我掏出来手机，还是对沙雕视频，漂亮姐姐，马老师的五连鞭，成华大道的二仙桥，念念不忘。\n被窝里面，我悄悄哈笑 ，却又感夜色悲凉，整个世界都变无聊。\n也是2020年。\n有人义愤填膺：这个时代，注意力是我们最宝贵的财富，而所有的app都是在收割我们的注意力，用越来越先进的算法最大化占用我们的时间，然后把它们转售给广告商，也就是互联网的赚钱逻辑。\n也有人语重心长：千万不要吸收太多碎片化的信息和知识，这些东西逻辑简单，理解轻松，表达流畅，让安慰式的学习，带给我们短暂而无用的满足感。\n还有人憨里憨气：我跟你嗦要远离高刺激，习惯了高刺激，习惯了高水平的分泌多巴胺，那些不够爽的事情我们就越来越不耐烦了，看书，学习，提高自己，我们越来越难集中注意力在这些，无趣而有用的事情上了。\n知道了这些之后，我本该抵制被动推荐，选择主动搜索。\n我明明应该当个小香猪漫山遍野地跑，拱自己想拱的白菜。\n但是现在，我已经习惯了被动投食，哼哼唧唧，B站的推荐，知乎的热榜。\n我深明大义，义无反顾，顾头不顾腚。\n一边排斥，一边真香，我清醒又荒唐，好玩又好笑。\n还是2020年。\n我 看到了，这个社会越来越两极分化，矛盾越来越大。\n贫富，两性，种族，东西方意识形态。\n不可调和，党同伐异，中门对狙，站队互喷，nmsl。\n贫富差距越来越大，阶级越来越固化，上升的通道越来越窄。\n公司在裁员，学历在贬值。\n焦虑，一时间，好像变成了所有人，通向未来的唯一解。\n以及，慢慢地，汹涌澎湃的2020，我的情绪也变得越来越钝化了。\n我不再因为万里之外的不幸之人悲伤，我也不再因为千里之外的不公之事而愤怒。\n我看到的现实，赤裸裸，血淋淋，一波又三折，反转又反转。\n我再难感他人的不幸，再难再愤他人之所慨。\n我慢慢开始变得边界分明。开始变得冷漠又麻木。\n疫情过后，生活慢慢一切如常，我却大梦初醒。\n才发现，我其实自己一直都在跑道之上，跑道名曰人生，有人从未停息。\n我前瞻后顾，左顾右盼，好像周围的人，他们都在逆袭。\n但是，我却越来越无力，一种更可怕无力，我明明道理都懂，还是不愿意往前走的无力。\n我一边堕落，一边上进。\n坠落谷底，仰望天空。\n但是，我目力所及的身边也好，还是互联网的众生芸芸，还是有好多人在努力生活，在传递温柔，在朝着自己的目标全力以赴。\n他们跟我说“我们可以改变自己，大脑可以改造，性格可以改变，感性可以朝着理性引导，理性也可以温柔表达”\n没有人想堕落，也没有人想丧失人生的主导权，生活的控制权。\n也没有谁想，把自己变好的愿望，不合理地寄托于看到的某个视频，听到的某个故事，知道的某个道理，掌控的某个方法。\n清醒的人都知道，这虚无缥缈，满纸荒唐。\n我尝试了好多次，我试着做出改变，却屡战屡败。\n我发现，真的好难啊。\n大量碎片化的知识和信息已经不可阻挡地重塑了我的大脑，它变得越来越喜欢简单好玩的，越来越不愿意去思考，越来越不愿意发生改变，也越来越懒得质疑。\n大量高刺激的信息流，知乎抖音B站的精准推荐，已经让我适应了高刺激，我的大脑已经越来越难从低刺激的学习阅读里面，得到多巴胺，去得到学习的动力了。我们好像越来越愿意活在当下，越来越不相信未来了。\n在那些社交平台博主分享的视频经历里面，我已经考上北大清华了，也体验了月薪十万百万的生活，我参与过了国家大事，曾经带着俺的键盘冲锋陷阵，有死无生。你说看世界啊，也去过啦，极光海岛，温泉火山。\n醒过来的时候，我呆呆地发现，我还在原地。\n只是，人潮变得越来越拥挤了，我变得更焦虑了。\n身边的人都已经超过我太多太多了。\n因为自尊也好，虚荣也好，好胜不甘心也好，我还是觉得，现在就躺平，认了所谓虚无缥缈的命，我舍不得，不可能，不愿意！\n但是我是一个很难因为认同什么，因为什么共鸣去持续努力的人，我需要那种能够说服我去努力的底层原理。\n身边的人都已经超过我太多太多了。\n因为自尊也好，虚荣也好，好胜不甘心也好，我还是觉得，现在就躺平，认了所谓虚无缥缈的命，我舍不得，不可能，不愿意！\n但是我是一个很难因为认同什么，因为什么共鸣去持续努力的人，我需要那种能够说服我去努力的底层原理。\n最后，我找到了，三句话。\n第一句，”人是自我编制意义之网的生物，人只有在不快乐的时候才会思考意义，也只有在闲下来的时候才会寻找意义。“\n第二句，”我们对时间的感知其实非常主观，我们越习惯于我们的生活方式，生活里面的新鲜感就越少，我们对时间的感知就越快，生命就越短。“\n第三句，”人生应该走向“相对自由”适量选择的自律，而不是“绝对自由”无限选择的混乱。自律是自由的最终形态，在规则内我们才能最大化地感知自由。”\n我写下来这一段话：\n活着，不可能停下来，因为停下来我们就会适应刺激。\n所以我要不停地去新的地方，遇见新的人，去追求追逐下一个目标。\n去扩展新的认知边界，去接受新的知识，接受新的观念。\n永远不要满足，永远都不要自以为是，永远都在路上。\n要活得更长，活着更久，活得更有意义。\n我只能永远活在未知，活在挑战，活在成长里面。\n我终于决定改变，我知道我之前很烂，所以我只能慢慢改。\n我把改变分成了三段。\n开始早睡早起，因为作息是高效的底层保障。\n关闭了朋友圈退出了社交平台，不想太关注于别人，因为别人消耗太多精力和情绪，因为圈子之外的”极端“和”典型“而焦虑。\n换了小屏手机，删掉了所有的社交娱乐app，逃离高刺激。\n第一幕：一个人的咸鱼程度正比于，从醒来到起床，从上床到睡觉的时间和。\n关于早起。\n用早起的仪式感，给一天的开始赋能，然后去完成最有挑战性的事情，能得到一种极大的满足感和成就感。\n以及，关于”痛苦的早起“基调的奠定，一天的情绪氛围会稍微发生一些改变，也就是会有一种”使命感“，大概就是相信，我是来吃苦的。\n今天已经努力早起了，我今天不能懈怠，要努力冲冲冲！\n以及，悄悄改变的核心，让我相信我可以掌控我的一天，”我比大多数人都起得早“，还来得及，还追得上，抚平了我的很多焦虑。\n关于早睡。\n晚上容易感性，负面情绪会变多。华灯初上，我们跟外界的交流切断，就会转向自我，审视，思虑。而同时，身体的疲惫，一天的学习和工作，导致稳定情绪的血清素浓度降低，就更容易被情绪主导，顾影自怜，苛责自我，后悔苦恼。\n而偏偏，大部分人都会选择延长这一份独独属于自己的时间，包括我。\n白天的时间是属于别人的，晚上的时间是属于我的，晚一点睡觉，因为我想要一点掌控感。\n白天什么都没有做，荒废了一天，晚上多撑一会，因为我想多一点理所当然。\n同时，信息焦虑，对信息高刺激的依赖，睡前大量刷视频看文字，睡觉的时候更难平复心绪，反而带着一种更大的空虚和焦虑以及负罪感。\n我突然发现，这个时代，已经让我对信息刺激，极端敏感，极度依赖。乃至于，我们连睡前片刻的「屏蔽」，短暂地脱离，都做不到。\n对早睡，我定下的原则是，不带手机上床，睡前避免高刺激。\n我知道，规律作息不一定能让我逆袭，但是，堕落，一定是从作息不规律开始的。\n开始早睡早起，让我相信了我可以改变，让我相信了我可以重新掌控生活，让我相信了我还来得及，追得上。\n第二幕：圈子之外的人，其实不用在意，圈子之内的人，也可以不用那么关注。\n圈子之外的人，带给我们大多是焦虑。\n幸福感其实一定程度上是来自于比较的，以前我们的比较标准仅仅来源于我们目力所及之人。\n而现在我们的比较标准，被“人生赢家们”被“分享者们”无限拔高了。\n不知道从什么时候开始，社交平台变成了一个橱窗，里面装点精致。\n透过深深的滤镜，他们生活灿烂，情绪热烈，人设完美。\n其实，我们是清楚这种虚幻的不真实感的，而社交平台，恰恰就是有这样的魔力，让我们沉浸。\n我们明明知道，这些逆袭清北上交，这些年入千万百万，这些生活精彩情感丰富，所谓的人生赢家们。\n是“典型”，是“极端”，是“幸存者”们。\n但是他们出现得太频繁了，但是他们展先的形式太粗暴了，以至于，扭曲了我们认知，我们的大脑悄悄把他们当成了常态，当成了标准。\n我们的预期被不断拔高，我们的平均标准也在提高，我们对取得的成就越来越不满意，我们越来越焦虑。\n我们再回头来看我们的一步一步努力，我们的慢慢进步，甚至可能产生”别人已经那样了，我现在才这样，我是不是废物啊”的极端下个发。\n大部分人其实都是，一边挣扎，一边努力，偶尔迷茫，偶尔鸡血。\n这些东西才是生活的常态。\n有些人的生活，其实我们不用看。\n其实，橱窗里面的很多生活，在一边灿烂，在一边腐烂。\n所以，我关闭了，我不想再看了。\n对待圈子之内的人。\n我想说，我们其实并不用因为别人的评价去怀疑自己。\n意见和评价，只是用来参考的，但是标准在我们自己身上。\n有些人的建议，其实我们不用听。\n有自我意识，并不代表去自私，而是在任何时候任何时间都选择尊重自己的情绪，尊重自己的利益。\n没必要博眼球，也没必要找认同。\n如果太在意别人的看法，因为别人的期待而改变。\n但是，不同的人有不同的期待，不同的人有不同的看法，不同的人对你有不同的要求。\n去不停地改变形状，那，我原来的形状是什么？\n我关掉了朋友圈，它对我的意义并非切断社交。\n而是，我想通过这个仪式感来告诉自己，我应该有自己的形状，我可以不那么在意别人的想法。\n第三幕：高刺激，碎片化的信息，只会让人变蠢。但是我打不过，只能跑。\n我们的基因，是几百万前的基因。\n干不过现在的科技。\napp的推荐算法，推荐机制，可以说，已经从我们的基因层面，生理层面，认知层面，在全方面降维打击我们。\n沙雕视频，漂亮姐姐，这些是人类原始的生理需求，我知道，一刷就停不下来。\n所以，我为了让自己不方便，换了小屏手机。\n我为了让自己更不方便，我还是删掉了所有app。\n我太知道我是个怕麻烦的人了，一旦我想着要重新下载，还要重新登录，还要在那个逼仄的屏幕内寻求高刺激。\n我就想，算了，还是好好学习。\n其实设置的路径长一点，大脑也许就能反应过来了。\n因为大脑是有两个认知通路的，一个是感性主导的，一个是理性主导的。\n一般来说，感性主导就是我们的第一反应，也就是脑子一热。\n理性主导会慢很多，也就是事后一想。\n给大脑一点时间，让它反应反应。\n也许，它就能做正确的决定了。\n此时此刻。\n我并没有逆袭，但是，我在一步一步变好。\n我心安理得，我开始变得不那么焦虑，我开始对生活有掌控感。\n没有那么热血，没有那么刺激，也没有那么多鸡血。\n有的只是，尊重现实。\n从生理上认知上思维上，去接受自己，对自己的感性少点责备，对自己的低行动力少点强求，对科技多点警惕，打不过就跑。\n借助于工具，借助于仪式，从认知开始，和习惯协调，知行合一，引导自己慢慢自律。\n未来，慢慢来吧。\n最后。\n我想说，这就是我一个普通人。\n重新掌控生活的三步，没有那么热血，也没有那么刺激，也没有逆袭故事。\n有的，只有，更好地去认知自我，对自己的一些行为一些心理少一点责备。\n然后通过工具，通过习惯，慢慢地对自己我进行改造。\n\n\n转载自：生于焦虑，死于自律\n\n","plink":"https://becase.top/resources/excerpt/生于焦虑-死于自律/"},{"title":"给青年添个堵","date":"2023-07-11T08:54:19.196Z","date_formatted":{"ll":"Jul 11, 2023","L":"07/11/2023","MM-DD":"07-11"},"updated":"2023-07-11T08:54:19.196Z","content":"你们是被赞美的青年。\n但此刻我不想赞美你们。\n你们可以以极低的成本，随时随地用各种方式\n看到、听到、触碰到全人类几千年间孕育出的\n最好的、最壮丽的、最伟大的、最丰富的产物。但你们并不在乎\n你们怀疑一切\n你们说A无非是19世纪资产阶级的无病呻吟\nB不过是浪漫主义对传统艺术的不成熟的挑战\nC受到当时社会中流行的某某观念的局限。\n你们解构一切\n你们一个字一个词地解读小说\n你们一帧一秒地去拆分电影\n你们关注时代背景，作者的故事，风格流派\n你们吸收无数的二手的、三手的、五六手的\n二流解读和戏说。\n但我想问你\n它们究竟让你感受到了什么？\n你有哪些纯粹个人的、具体的、细致的触动？\n你们茫然四顾\n你无从回答。\n你们出生在一个鼓励表达\n奖励个性的时代\n你们拥有无数种笔，无数种话筒\n你们有极强的表现欲和表达欲\n你们急切的让世界听到自己的声音。\n你们是舆论场上的异见者\n激烈的反对庸俗，反抗丑恶\n于是你们留言、评论、私信、转发。\n四处留下话语，\n但它们是什么？\n你们说这不正确，这有问题\n这是一句不该说的话，这不符合身份\n另一个同样的你站出来，说你政治正确，\n你是圣母婊，而这显然又是另一种不正确。\n你们的心被挤压到还不到手机上的SOC大\n你们甚至要去管谁谁谁在喝酒抽烟\n你们甚至要去管那些20岁出头荷尔蒙满满溢出\n明明和你们一样大的偶像谈不谈恋爱。\n你们到处出击挖坟清算\n用放大镜去寻找别人的漏洞和弱点\n要求一个又一个人道歉。\n逼迫他们说出了占用公共空间。\n但公共空间没有被占用\n让给你们的时候\n你又能往里面放些什么呢？\n你们一腔愤怒无处发泄，\n你们执着于痴迷于宏大的结构，\n但对具体的个人视若无睹。\n你们把一个又ー一个几乎与你们没有差别的个体贴上标签，\n甚至把世界上50%的另一种性別异化成怪物，\n然后你们重拳出击。\n你们一争论起来就扣帽子\n降低自己人设\n千方百计让对方难堪。\n在这之外\n你们还有没有能力进行正常的\n有基本同理心的、平静的、有价值的交流？\n你们在每一个热点事件出现的时候\n迫不及待的去搜索答案\n你们看不计其数的各种各样的回答\n吸纳了无数的理论和概念\n你们头脑中环绕着500个现成的框架\n它们可以依附在每一个新的问题上面。\n但除此之外\n你们是不是在洗澡时，吃饭时，人眠前，谈话中\n还能够诞生出原原本本的源自于你本人的见解？\n哪怕它们简单而朴素？\n你们有着极佳的网感\n你们熟悉每一个梗\n你们嘲笑中年人和下沉群体的老套与过时。\n但去除那些梗\n那些表情包\n那些抽象话\n和粗暴的定义之外\n你们又是怎样一群无聊、空洞、狭隘的人？\n此时此刻你们在弹幕上刷别骂了\n好像这是一句幽默的玩笑话\n那么，没有了这些东西\n你们是否还有能力说出一段言之有物的\n完整的、有趣的话？\n你们知道很多\n你们空无一物。\n这是一个前所未有的物质极大丰富\n价值观和选择多元化的世界\n生活摆在你们面前有无数条路。\n然而，泥泞的路，光滑的路，粗粝的路\n闪光的路，墨绿色的路，散发着海腥味道的路\n在你们看来都是同一种路\n你们不关心别的\n你们只关心它们能延展到多远多高的地方。\n你们看似丰富，多彩，狂野\n但那些只是RGB调色盘上1678万中选项中的一个\n只有你们知道自己的怂，\n自己的软弱和胆怯。\n你们患得患失\n把一切东西都按照一般等价物去换算\n连出门吃顿饭都要在AP上对比15家饭馆生怕选错\n你们有微信，有陌陌探探\n但却只敢在愚人节伪装成恶作剧怯懦地发出表白。\n你们被一切的一切的一切的一切東住双脚\n你们裹足不前\n你们蹦迪买潮牌听黑怕，好像对一切都满不在乎\n但你们从学生时代起就战战兢兢\n把求最优解已经内化成了一种生理习惯。\n你们身份证上写的是20岁\n说着10岁的话\n打着40岁的算盘\n像60岁一样的行动。\n你们，真的能叫\n青年？\n今天，所有人都在赞颂青年\n但我要说，青年没什么了不起\n青年并不一定优秀，并不一定深刻\n并不一定勇敢，并不一定有创造力\n青年唯一的优势，不过是时间站在你们这边。\n正因为时间尚早，太阳正当空\n你们没有过往的束缚\n你们能够以一双崭新的眼看到无数种可能性\n你们可以说出新的话\n你们有不加掩饰的欲念和期望\n你们想看到更多东西\n做心心念念的事情，让自己变得不一样。\n所以你们才更优秀\n更深刻\n更勇敢\n更有创造力。\n我是80年生人，但我是一名青年。\n你呢？\n你是什么样的青年\n\n\n转载自：给青年添个堵\n\n","plink":"https://becase.top/resources/excerpt/给青年添个堵/"},{"title":"语文高考作文可以写负能量作文吗","date":"2021-07-07T00:00:00.000Z","date_formatted":{"ll":"Jul 7, 2021","L":"07/07/2021","MM-DD":"07-07"},"updated":"2023-07-11T08:54:19.196Z","content":"我真的是服你们这群崽子。\n一个个的都是契科夫转世、莫泊桑临凡、欧亨利还魂，茨威格夺舍……\n你们三天没洗的油头上散发的是莎士比亚时代遗留的思想圣光，一月未换的袜子里氤氲着文艺复兴时期的蓬勃蒸汽，龙飞凤舞的狗爬字体饱含着千年中华的伟大传承。\n你们就是鲁迅后院子里的那两棵树，一棵是朴树，另一棵是村上春树，你们的根系绵延不绝，从白鹿原一直聊骚到挪威的森林，阿来匍匐在你们脚下，贾平凹仰望着你们的膝盖，刘慈欣率领的整个三体舰队，都被你们炫彩夺丽的文采所折服，把你们的大作顶在脑壳上一路跪着爬回去的。\n我看你们就差脑壳上刷上几个金光闪闪的烫金大字——爷怀才不遇！\n就一句话，只要你文笔好，三观正，不给法西斯洗地，不给罪犯挡枪，不为封建糟粕招魂，你们爱写什么写什么，想写什么写什么…… 这些都不是问题。\n你要真的才比李太白，文盖托尔斯泰，你的老师也不会是那嫉贤妒能的张士贵，不会针对你这个人民代表大会上的应梦贤臣。\n唯一的问题是:\n锁了房门丢钥匙——您配吗？\n我就想知道，您十八年的人生究竟度过的多么灰暗？才让您的脑子里充满了这宛如七月十五红衣上吊冤死鬼般的怨气，非要在一个人生比重前几名的考试里玩一把个性，赌一把人生？你是昭和日本在中国的遗孤吗？动不动就要皇国兴废，在此一举？\n区区八百字的篇幅，您是打算用什么样的方式组织一个莫名其妙的负能量宣泄？喊麦吗？惊雷，这通天彻底紫金锤？\n你失过业？下过岗？去过夹边沟农场？\n你扛过枪？打过仗？家里上了一炷香？\n你炼过钢？交过粮？吃过红薯拌高粱？\n你贷过款？买过房？女友身边躺老王？\n你有个卵子的负能量？\n校花没喝你拿早餐钱买的奶茶，你就抑郁了？王者连掉十几个段位，你就顿悟了？你哥们放学拉稀没跟你一起走，你就觉得被背叛了？你爹妈随口叮嘱你一句，你就被全世界针对了？\n醒醒吧，你见过什么负能量？奈何桥上你不喝汤孟婆还得掉业绩呢，满月时候嘴里啃坨屎你还乐的像喝了奶一样呢，穿着个开裆裤满床尿尿的时候也没见你单手托腮 cos 个沉思者啊？\n高考作文的难度一降再降，从话题作文到材料作文再到近些年就差给你出个写作攻略的任务驱动型作文，考察的不过是你好好说话的本事。\n可你就是不想好好说话！\n国家贴着钱给你九年义务教育，补着款迎接你去高等学府，就想在作文里听你夸两句怎么了？过分吗？让你赞美个无私奉献夸耀个科技发达听一句积极向上要你的命吗？你就非给人找不痛快？你就非要大年三十送棺材，满月酒上做花圈？\n平常懒得写随笔，模考字数凑不够，名著没翻过几本，拿起手机就忘了娘，掂起笔就石乐志，结果一到考场上你诗情画意全都来了，恨不得洋洋洒洒疾书去，一步三叹不回头？\n你要真的是忧国忧民，文采斐然，就是能在八百字左右的篇幅里控诉出这黑暗的世界、不公的现实，让人读了悲从心起潸然泪下，老师看了齐声喝彩拍案叫绝，整个文学界为之震动…… 那你就不会再乎分数了，你都堪破红尘世俗，洞悉人心宇宙了，还纠结老师给不给你分干嘛？俗气！你追求的应该是 “他年我若为青帝，报与桃花一处开” 的豪迈或者 “残躯徒留红尘里，此身不在五行中” 的洒脱，不是吗？\n\n\n转载自：语文高考作文可以写负能量作文吗\n\n","plink":"https://becase.top/resources/excerpt/语文高考作文可以写负能量作文吗/"},{"title":"书籍清单","date":"2023-04-29T00:00:00.000Z","date_formatted":{"ll":"Apr 29, 2023","L":"04/29/2023","MM-DD":"04-29"},"updated":"2023-07-11T08:54:19.196Z","content":"过去\n初中时从电子书开始，高中因为学校管制原因多为意林、读者等文刊，偶尔私下买借几本来看\n每当回想起晚自习拿着小说放在课桌上充当学习资料看的时候，心里还是不免咯噔一下，仿佛班主任的死亡凝视微笑就在背后:)\n主体\n\n追风筝的人\n摆渡人\n小王子\n天才在左，疯子在右\n笑场@李诞\n你当像鸟飞往你的山\n人生的智慧@叔本华\n白说@白岩松\n他和她的猫@新海诚\n三体全集\n雪国\n福尔摩斯.全集\n成佛之后，成仁之前\n社会性动物\n\n韩寒\n\n1988：我想和这个世界谈谈\n三重门\n青春\n通稿2003\n\n江南\n\n龙族.全集\n天之炽\n龙与少年游\n\n卢思浩\n\n时间的答案\n离开前请叫醒我\n你也走了很远的路吧\n\n龙应台\n\n亲爱的安德烈\n目送\n解忧杂货店\n\n东野圭吾\n\n幻夜\n麒麟之翼\n解忧杂货店\n白夜行\n嫌疑人x的献身\n\n刘慈欣\n\n三体.全集\n超新星纪元\n2018\n流浪地球\n\n省去那些中二玄幻小说\n技术类\n从大学的图书馆伊始\n\nC primer plus.6\n数据结构与算法（黑皮书\n深入理解计算机系统\nJava核心技术.上、下\nJavaScript高级程序设计.3（红宝书\nCSS世界@张鑫旭\n\n","plink":"https://becase.top/resources/list/书籍清单/"},{"title":"影视清单","date":"2022-11-29T00:00:00.000Z","date_formatted":{"ll":"Nov 29, 2022","L":"11/29/2022","MM-DD":"11-29"},"updated":"2023-07-11T08:54:19.196Z","content":"既要读万卷书，也要走千里路。影视你看过，影视的幕后呢?\n演员背后的人设，剧情于现实的映射，观众对故事的共情，这才是影视传递的价值导向。至于荧幕上的，不过是人有选择的放给人看的\n电视\n\n绝命毒师\n纸牌屋\n\n电影\n\n深海\n铃芽之旅\n满江红（x\n剑雨\n布达佩斯大饭店\n\n动漫\n\n画江湖之不良人6\n灵能百分百\n\n2023的过去\n只记录一些印象深刻的，顺序没有先后意义，有些遗忘的后续会补上\n123456格式说明- 无@：表示电影- @：剧表示动漫- @@：表示电视- @@@：表示纪录片- 后缀x：表示不推荐\n\n肖申克的救赎\n坏蛋必须死\n这个杀手不太冷\n@紫罗兰的永恒花园\n@钢之炼金术师\n小丑\n楚门的世界\n三傻大闹宝莱坞\n怦然心动\n放牛班的春天\n楚门的世界\n泰坦尼克号\n海上钢琴师\n喜剧之王\n@@琅琊榜\n@星际牛仔\n@@@浮生一日\n@浪客剑心_追忆篇\n南方车站的聚会\n树先生\n与神同行.1.2\n你好，之华\n情书\n@@庆余年\n@画江湖之不良人4\n@@请回答1988\n@@老友记\n@@是，首相\n@@神探夏洛克\n美丽人生\n星际穿越\n盗梦空间\n忠犬八公的故事\n教父.1.2\n我不是药神\n让子弹飞\n了不起的盖茨比\n猫鼠游戏\n闻香识女人\n绿皮书\n黑客帝国.全集\n寄生虫\n@进击的巨人\n@夏目友人账\n白日梦想家\n@东京喰种\n\n宫崎骏和新海诚\n\n你的名字\n言叶之庭\n天气之子\n烟花\n千与千寻\n红猪\n哈尔的移动城堡\n声之形\n\n","plink":"https://becase.top/resources/list/影视清单/"},{"title":"The Boy","date":"2023-06-15T00:00:00.000Z","date_formatted":{"ll":"Jun 15, 2023","L":"06/15/2023","MM-DD":"06-15"},"updated":"2023-07-11T08:54:19.196Z","content":"眼下是一条千来层的笔直石阶，远眺望不到头，我走在下山的台阶上。\n本是冲出云层的高山，奇怪的是看不到两侧的瑰丽，路边只有原木做的扶梯。我只顾往下走着，不一会儿就看到前方蹲着一个小孩，他背对着我，带着欢快的笑声。好似发觉了我的存在，他起身也往下赶路，我不理解，便加快了我的步伐，一级台阶本需常人一步，我却三四阶地向下分段跳跃，小孩还是一阶又一阶的走着。按照这种相对速度本应该很快就能追上的，可我们的距离却诡异的保持着不变。\n这样持续了没多久我看到前方又多了两个身影，走进了才知道在路边站着两个小女孩。那个小孩走到她们身边时便停下了脚步，转眼间我也到了。女孩当中有个扎着两个小辫子，开始跟小孩打招呼，你来我往的他们三就聊起来了，我走到和小孩并齐的位置，没等我插嘴她们当中的另一个女孩就突然转向我，笑着说“你也来了呀。”我满脸疑惑，侧过头看向小孩，看着这张脸莫名的熟悉，没等我开口问，刚刚的女孩又说到，“哈哈，原来你长大后这么木讷啊”，脸是朝着小孩说的。小孩见状笑得更大声了，一边朝我伸手一边说着：“你好呀，未来~”\n时间突然定格在了那一刻，各种回忆和逻辑突然在我脑海里以幻灯片的形式自动播放，我三步并一步的习惯是高三养成的，下山时小孩和我的距离不变的原因，是我们年龄差距的时间一直不变，两个小女孩就是我的小学和中学，下山的路是我回到过去的路。\n然后就惊醒了。\n","plink":"https://becase.top/resources/notes/theboy/"},{"title":"小阳人的自我修养","date":"2022-12-15T00:00:00.000Z","date_formatted":{"ll":"Dec 15, 2022","L":"12/15/2022","MM-DD":"12-15"},"updated":"2023-07-11T08:54:19.196Z","content":"\n判断是不是：喉咙有问题、发烧、浑身发冷无力，三中二就是中招了\n退烧药一定得有，可以不是布洛芬，但得有，其他症状酌情吃药\n大量喝电解质水：普通水+柠檬+少量白糖+更少量食用盐，混匀烧开喝\n正常流程：喉咙干痒一天，发烧两到三天，咽痛两三天，期间伴随咳嗽和流鼻涕，然后缓解一两天，总共七天左右（严重的表现有吞刀片、浑身痛、失去嗅觉味觉等）\n不同时期不同症状吃不同药，有些药不能混吃（阿莫西林除非后期真的发炎，否则不要吃\n判断好没好：身体症状基本消失（可能还会有点咳嗽，但流鼻涕咽痛就不行）+两次核酸阴性\n有数据表明，过敏患者或者鼻炎患者，感染症状相对较轻（我自己就是，感觉有道理\n\n","plink":"https://becase.top/resources/notes/小阳人的自我修养/"}]