{"title":"Java中的集合","date":"2021-04-17T20:55:40.000Z","date_formatted":{"ll":"Apr 17, 2021","L":"04/17/2021","MM-DD":"04-17"},"link":"2021/04/17/Java中的集合","comments":true,"tags":["java"],"categories":["back-end"],"updated":"2023-07-11T08:54:19.192Z","content":"<p>记述一下 Java 中的部分相关接口与具体实现类：<br>\n<img src=\"http://cdn.becase.top/20220413191250.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"具体容器分类\">具体容器分类<a title=\"#具体容器分类\" href=\"#具体容器分类\"></a></h3>\n<blockquote>\n<ul>\n<li>非同步集合：在并发访问的时候，是非线程安全的；但是由于它们没有同步策略(加锁机制)，它们的效率更高</li>\n<li>同步集合：对每个方法都进行同步加锁，保证线程安全</li>\n</ul>\n</blockquote>\n<p><strong>非同步集合</strong>：ArrayList、HashSet、HashMap、LinkedList、TreeSet、TreeMap、PriorityQueue<br>\n<strong>同步集合</strong>：HashTable、Vector、Stack</p>\n<p>同步包装器 : [ Collections.synchronizedMap(), Collections.synchronizedList() ]</p>\n<p>Java 集合类中非线程安全的集合可以用同步包装器使集合变成线程安全，其实实现原理就是相当于对每个方法加多一层同步锁而已，比如：</p>\n<ul>\n<li>HashMap --&gt; Collections.synchronizedMap(new HashMap())</li>\n<li>ArrayList --&gt; Collections.synchronizedList(new ArrayList&lt;&gt;())</li>\n</ul>\n<p><strong>并发集合</strong>：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList、CopyOnWriteArraySet、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque、ConcurrentLinkedQueue</p>\n<h3 id=\"同步集合类和并发集合类的区别\">同步集合类和并发集合类的区别<a title=\"#同步集合类和并发集合类的区别\" href=\"#同步集合类和并发集合类的区别\"></a></h3>\n<p>不管是同步集合还是并发集合他们都支持线程安全，他们之间主要的区别体现在性能和可扩展性，还有他们如何实现的线程安全。</p>\n<p>同步集合类，Hashtable 和 Vector 还有同步集合包装类，Collections.synchronizedMap()和 Collections.synchronizedList()，相比并发的实现(比如：ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteHashSet)会慢得多。</p>\n<p>造成如此慢的主要原因是锁， 同步集合会把整个 Map 或 List 锁起来，每个操作都是串行的操作，同一时刻只有一个线程能操作。而并发集合不会，并发集合实现线程安全是通过使用先进的和成熟的技术把锁剥离。</p>\n<p>比如 ConcurrentHashMap 会把整个 Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。</p>\n<p>CopyOnWriteArrayList 允许多个线程以非同步的方式读，当有线程写的时候它会将整个 List 复制一个副本给它。如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性</p>\n<h3 id=\"queue-接口\">Queue 接口<a title=\"#queue-接口\" href=\"#queue-接口\"></a></h3>\n<p>Queue 接口包括 Collection 接口的所有方法。 这是因为 Collection 是 Queue 的超级接口。</p>\n<p>Queue 接口的一些常用方法是：</p>\n<ul>\n<li><strong>add()</strong> - 将指定的元素插入队列。如果任务成功，则 add()返回 true，否则将引发异常。</li>\n<li><strong>offer()</strong> - 将指定的元素插入队列。如果任务成功，则 offer()返回 true，否则返回 false。</li>\n<li><strong>element()</strong> - 返回队列的开头。如果队列为空，则引发异常。</li>\n<li><strong>peek()</strong> - 返回队列的开头。 如果队列为空，则返回 null。</li>\n<li><strong>remove()</strong> - 返回并删除队列的头部。如果队列为空，则引发异常。</li>\n<li><strong>poll()</strong> - 返回并删除队列的开头。 如果队列为空，则返回 null。</li>\n</ul>\n<h3 id=\"deque-接口\">Deque 接口<a title=\"#deque-接口\" href=\"#deque-接口\"></a></h3>\n<p>在常规队列中，元素是从后面添加的，而从前面删除的。但是，在双端队列中，我们可以<strong>从前后插入和删除元素</strong><br>\n<img src=\"http://cdn.becase.top/20220413190110.png\" alt=\"\" loading=\"lazy\"></p>\n<p>除了 Queue 接口中可用的方法之外，Deque 界面还包括以下方法：</p>\n<ul>\n<li><strong>addFirst()</strong> - 在双端队列的开头添加指定的元素。如果双端队列已满，则引发异常。</li>\n<li><strong>addLast()</strong> - 在双端队列的末尾添加指定的元素。如果双端队列已满，则引发异常。</li>\n<li><strong>offerFirst()</strong> - 在双端队列的开头添加指定的元素。如果双端队列已满，则返回 false。</li>\n<li><strong>offerLast()</strong> - 在双端队列的末尾添加指定的元素。如果双端队列已满，则返回 false。</li>\n<li><strong>getFirst()</strong> - 返回双端队列的第一个元素。如果双端队列为空，则引发异常。</li>\n<li><strong>getLast()</strong> - 返回双端队列的最后一个元素。如果双端队列为空，则引发异常。</li>\n<li><strong>peekFirst()</strong> - 返回双端队列的第一个元素。如果双端队列为空，则返回 null。</li>\n<li><strong>peekLast()</strong> - 返回双端队列的最后一个元素。如果双端队列为空，则返回 null。</li>\n<li><strong>removeFirst()</strong> - 返回并删除双端队列的第一个元素。如果双端队列为空，则引发异常。</li>\n<li><strong>removeLast()</strong> - 返回并删除双端队列的最后一个元素。如果双端队列为空，则引发异常。</li>\n<li><strong>pollFirst()</strong> - 返回并删除双端队列的第一个元素。如果双端队列为空，则返回 null。</li>\n<li><strong>pollLast()</strong> - 返回并删除双端队列的最后一个元素。如果双端队列为空，则返回 null。</li>\n</ul>\n<h3 id=\"linkedlist-类\">LinkedList 类<a title=\"#linkedlist-类\" href=\"#linkedlist-类\"></a></h3>\n<p>Java 中的链表具体实现类，对比 ArrayList 的<strong>增加和删除</strong>的效率更高，而<strong>查找和修改</strong>的的效率较低</p>\n<h3 id=\"arraydeque-类\">ArrayDeque 类<a title=\"#arraydeque-类\" href=\"#arraydeque-类\"></a></h3>\n<p>实现了 <strong>Queue 接口</strong> 和 <strong>Deque 接口</strong><br>\n<img src=\"http://cdn.becase.top/20220413190555.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"stack-类\">Stack 类<a title=\"#stack-类\" href=\"#stack-类\"></a></h3>\n<p><code>Stack&lt;T&gt; stack = new Stack&lt;&gt;();</code></p>\n<ul>\n<li>\n<p>boolean empty()<br>\n测试堆栈是否为空。</p>\n</li>\n<li>\n<p>Object peek( )<br>\n查看堆栈顶部的对象，但不从堆栈中移除它。</p>\n</li>\n<li>\n<p>Object pop( )<br>\n移除堆栈顶部的对象，并作为此函数的值返回该对象。</p>\n</li>\n<li>\n<p>Object push(Object element)<br>\n把项压入堆栈顶部。</p>\n</li>\n<li>\n<p>int search(Object element)<br>\n返回对象在堆栈中的位置，以 1 为基数。</p>\n</li>\n</ul>\n<blockquote>\n<p>Java 集合框架中没有 Stack 接口，仅有 java 早期遗留的一个 Stack 类</p>\n<ul>\n<li>因为集成子 Vector，所以 Stack 类是同步的，效率不高，推荐用 ArrayDeque 代替</li>\n</ul>\n</blockquote>\n<h3 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h3>\n<p><a href=\"https://blog.csdn.net/weixin_31630721/article/details/114672989\" target=\"_blank\"># java 栈容器_Java 并发技术栈</a></p>\n<p><a href=\"https://www.cainiaojc.com/java/java-queue.html\" target=\"_blank\">Java Queue 接口</a></p>\n","prev":{"title":"strapi实践","link":"2021/04/23/strapi实践"},"next":{"title":"Hello World","link":"2021/03/16/hello-world"},"plink":"https://becase.top/2021/04/17/Java中的集合/","toc":[{"id":"具体容器分类","title":"具体容器分类","index":"1"},{"id":"同步集合类和并发集合类的区别","title":"同步集合类和并发集合类的区别","index":"2"},{"id":"queue-接口","title":"Queue 接口","index":"3"},{"id":"deque-接口","title":"Deque 接口","index":"4"},{"id":"linkedlist-类","title":"LinkedList 类","index":"5"},{"id":"arraydeque-类","title":"ArrayDeque 类","index":"6"},{"id":"stack-类","title":"Stack 类","index":"7"},{"id":"参考","title":"参考","index":"8"}],"reading_time":"1315 words in 9 min"}