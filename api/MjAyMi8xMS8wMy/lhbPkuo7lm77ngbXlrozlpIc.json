{"title":"关于图灵完备","date":"2022-11-03T00:00:00.000Z","date_formatted":{"ll":"Nov 3, 2022","L":"11/03/2022","MM-DD":"11-03"},"link":"2022/11/03/关于图灵完备","comments":true,"tags":["图灵"],"categories":["front-end"],"updated":"2023-07-11T08:54:19.192Z","content":"<h2 id=\"什么是图灵机\">什么是图灵机<a title=\"#什么是图灵机\" href=\"#什么是图灵机\"></a></h2>\n<blockquote>\n<p>图灵机（Turing Machine）是图灵在1936年发表的 “On Computable Numbers, with an Application to the Entscheidungsproblem”（《论可计算数及其在判定性问题上的应用》）中提出的 <code>数学模型</code></p>\n</blockquote>\n<p>既然是数学模型，它就并非一个实体概念，而是架空的一个想法。在文章中图灵描述了它是什么，并且证明了， <strong>只要图灵机可以被实现，就可以用来解决任何可计算问题</strong> 。</p>\n<h3 id=\"图灵机结构\">图灵机结构<a title=\"#图灵机结构\" href=\"#图灵机结构\"></a></h3>\n<p>图灵机的结构包括以下几个部分：</p>\n<ul>\n<li>一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。</li>\n<li>一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的<code>空白字符</code>（blank），意思是此格子没有任何字符。</li>\n<li>一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。</li>\n<li>一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解 <code>有限状态机</code>，它便对应着有限状态机里的状态。</li>\n<li>一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号53的格子并看到其内容为0时，擦除，改写为1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。</li>\n</ul>\n<p>在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：</p>\n<ul>\n<li>当前所处位置</li>\n<li>当前格子内容</li>\n</ul>\n<p>来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“…011001…”）便作为输出，由人来解码为 <a href=\"https://www.zhihu.com/search?q=%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A288346717%7D\" target=\"_blank\">自然语言</a>。</p>\n<p>要重申一下，以上只是图灵机模型的内容，而非具体的实现。所谓的纸带和读写头都只是图灵提出的 <a href=\"https://www.zhihu.com/search?q=%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A288346717%7D\" target=\"_blank\">抽象概念</a></p>\n<p>为便于理解打一个比方</p>\n<h3 id=\"抽象比喻\">抽象比喻<a title=\"#抽象比喻\" href=\"#抽象比喻\"></a></h3>\n<p>算盘虽然不是图灵机（因为它没有无限长的纸带，即无限的存储空间），但它的行为与图灵机一致。每一串算珠都是纸带上的一格，一串算珠上展示的数字便记录着当前格中的字符（可以是空白，可以是 12345 ）</p>\n<p>人类的手即是读写头，可以更改每串算珠的状态。算盘的运行遵循人脑中的算法，当算法结束，算盘停机</p>\n<h2 id=\"图灵机可以解决什么问题\">图灵机可以解决什么问题<a title=\"#图灵机可以解决什么问题\" href=\"#图灵机可以解决什么问题\"></a></h2>\n<p><strong>假设</strong> 上述模型里所说的功能都能被以某种形式物理实现， <strong>那么</strong> 任意可计算问题都可以被解决</p>\n<blockquote>\n<p>在计算机领域，或者说自动机领域，我们研究的一切问题都是计算问题（Computational Problem）。它泛指一切与计算相关的问题。</p>\n</blockquote>\n<p>计算问题的一些举例：</p>\n<ul>\n<li>给定一个正整数 n，判断它是否是质数</li>\n<li>给定一个 01 序列，把它们按位取反</li>\n</ul>\n<p>非计算问题的例子：</p>\n<ul>\n<li>今晚吃什么</li>\n<li>为什么太阳从东边升起</li>\n</ul>\n<p>计算问题有的可以解决，有的不可解决。这就引出了计算问题的可计算性（Computability）</p>\n<p>如上面的问题 1，我们当然可以找到一个算法来解决判断任意正整数 n 是否为质数的问题（比如从2遍历到 n-1，看 n 是否可以整除它）<br>\n所以，问题 1 就是可计算的。</p>\n<p>也有一些不可计算的计算问题，比如著名的 <a href=\"https://www.zhihu.com/search?q=%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A288346717%7D\" target=\"_blank\">停机问题</a>（Halting Problem)</p>\n<blockquote>\n<p><strong>Halting Problem</strong>: given the description of an arbitrary program and a finite input, decide whether the program finishes running or will run forever.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">它的表述是这样的：给定一段程序的描述和该程序的一个有效输入，运行此程序，那么程序最终是会终止，还是会死循环下去？</span><br><span class=\"line\"></span><br><span class=\"line\">它是一个不可判定问题（Undecidable Problem）。即不存在一个 **通用** 算法，可以在任意输入下解决此问题</span><br><span class=\"line\"></span><br><span class=\"line\">图灵在文章里很优雅的用反证法推翻了假设“假设有这么一个算法可以解决任何停机问题”，从而证明了这样的算法并不存在</span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是图灵完备\">什么是图灵完备<a title=\"#什么是图灵完备\" href=\"#什么是图灵完备\"></a></h2>\n<p>图灵完备性（Turing Completeness）是针对一套数据操作规则而言的概念。</p>\n<p>数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。</p>\n<p>当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性</p>\n<h3 id=\"常见不完备原因\">常见不完备原因<a title=\"#常见不完备原因\" href=\"#常见不完备原因\"></a></h3>\n<p>图灵不完备的语言常见原因有循环或递归受限(无法写不终止的程序,如 while(true){}; ), 无法实现类似数组或列表这样的数据结构(不能模拟纸带). 这会使能写的程序有限</p>\n<h3 id=\"缺点\">缺点<a title=\"#缺点\" href=\"#缺点\"></a></h3>\n<p>图灵完备可能带来坏处, 如C++的模板语言, 模板语言是在类型检查时执行, 如果编译器不加以检查,我们完全可以写出使得C++编译器陷入死循环的程序.</p>\n<p>图灵不完备也不是没有意义, 有些场景我们需要限制语言本身. 如限制循环和递归, 可以保证该语言能写的程序一定是终止的.</p>\n<h2 id=\"直观理解图灵完备——brainfuck-语言\">直观理解图灵完备——Brainfuck 语言<a title=\"#直观理解图灵完备——brainfuck-语言\" href=\"#直观理解图灵完备——brainfuck-语言\"></a></h2>\n<p>如今主流的编程语言（C++，Java，Python，以及等等等等）都是图灵完备的语言</p>\n<p>关于语言优劣之争也只是在其封装、优化等方面，以及因为这些区别而产生的“不同语言适用于不同情况”的争执。如果我们回到最底层，就会发现它们可以实现的功能其实完全一样，并且本质上就是一个图灵机</p>\n<p>在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令</p>\n<p>语言虽然极致轻量，它却是一门图灵完备的编程语言</p>\n<blockquote>\n<p>Brainfuck is fully Turing-complete.<br>\n一门新语言功能语法很复杂，要用数学证明的方式确定性说明它图灵完备会很麻烦，但只要用这门新语言实现一个brainfuck的解释器，那么就必然证明了是图灵完备的</p>\n</blockquote>\n<h3 id=\"示例\">示例<a title=\"#示例\" href=\"#示例\"></a></h3>\n<p>先贴上一段 BF 的代码，体验一下它的画风：</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">++++++++</span> <span class=\"title\">[</span> &gt; <span class=\"literal\">++++</span> <span class=\"title\">[</span> &gt; <span class=\"literal\">++</span> &gt; <span class=\"literal\">+++</span> &gt; <span class=\"literal\">+++</span> &gt; <span class=\"literal\">+</span> &lt;&lt;&lt;&lt; <span class=\"literal\">-</span> <span class=\"title\">]</span> &gt; <span class=\"literal\">+</span> &gt; <span class=\"literal\">+</span> &gt; <span class=\"literal\">-</span> &gt;&gt; <span class=\"literal\">+</span> <span class=\"title\">[</span> &lt; <span class=\"title\">]</span> &lt; <span class=\"literal\">-</span> <span class=\"title\">]</span> &gt;&gt;<span class=\"string\">.</span> &gt; <span class=\"literal\">---</span><span class=\"string\">.</span> <span class=\"literal\">+++++++</span><span class=\"string\">.</span><span class=\"string\">.</span> <span class=\"literal\">+++</span><span class=\"string\">.</span> &gt;&gt;<span class=\"string\">.</span> &lt; <span class=\"literal\">-</span><span class=\"string\">.</span> &lt;<span class=\"string\">.</span> <span class=\"literal\">+++</span><span class=\"string\">.</span> <span class=\"literal\">------</span><span class=\"string\">.</span> <span class=\"literal\">--------</span><span class=\"string\">.</span> &gt;&gt; <span class=\"literal\">+</span><span class=\"string\">.</span> &gt; <span class=\"literal\">++</span><span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<p>这个程序编译运行后，控制台打印 “Hello World!”。</p>\n<p>BF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。</p>\n<p>语言里的 8 个有效字符分别是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 指针向右移动一格</span><br><span class=\"line\"></span><br><span class=\"line\">&lt; 指针向左移动一格</span><br><span class=\"line\"></span><br><span class=\"line\">+ 使指针当前格数值加一</span><br><span class=\"line\"></span><br><span class=\"line\">- 使指针当前格数值减一</span><br><span class=\"line\"></span><br><span class=\"line\">. 把当前格数值按 ASCII 表输出到终端</span><br><span class=\"line\"></span><br><span class=\"line\">, 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格</span><br><span class=\"line\"></span><br><span class=\"line\">[ 当指针当前值为 0 时，程序跳转至与之对应的 ] 之后；否则程序正常执行</span><br><span class=\"line\"></span><br><span class=\"line\">] 程序跳转回与之对应的 [ 处</span><br></pre></td></tr></table></figure>\n<p>有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 ‘A’ 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 ‘A’。</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">+++++</span></span><br><span class=\"line\"><span class=\"title\">[</span></span><br><span class=\"line\">&gt; <span class=\"literal\">+++++++++++++</span></span><br><span class=\"line\">&lt; <span class=\"literal\">-</span></span><br><span class=\"line\"><span class=\"title\">]</span></span><br><span class=\"line\">&gt;<span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<ol>\n<li>把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。</li>\n<li>循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。</li>\n<li>此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 ‘A’。</li>\n</ol>\n<h3 id=\"gif示例\">gif示例<a title=\"#gif示例\" href=\"#gif示例\"></a></h3>\n<p><a href=\"http://link.zhihu.com/?target=https%3A//openprocessing.org/sketch/516467/\" target=\"_blank\">Brainfuck Visualizer - FreddieRa - OpenProcessing</a></p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://www.zhihu.com/question/20115374/answer/28834671\" target=\"_blank\">什么是图灵完备</a></p>\n","prev":{"title":"web前端加密是否有意义","link":"2022/11/07/web前端加密是否有意义"},"next":{"title":"TS类型体操刷题tips","link":"2022/08/27/TS类型体操刷题tips"},"plink":"https://becase.top/2022/11/03/关于图灵完备/","toc":[{"id":"什么是图灵机","title":"什么是图灵机","index":"1","children":[{"id":"图灵机结构","title":"图灵机结构","index":"1.1"},{"id":"抽象比喻","title":"抽象比喻","index":"1.2"}]},{"id":"图灵机可以解决什么问题","title":"图灵机可以解决什么问题","index":"2"},{"id":"什么是图灵完备","title":"什么是图灵完备","index":"3","children":[{"id":"常见不完备原因","title":"常见不完备原因","index":"3.1"},{"id":"缺点","title":"缺点","index":"3.2"}]},{"id":"直观理解图灵完备——brainfuck-语言","title":"直观理解图灵完备——Brainfuck 语言","index":"4","children":[{"id":"示例","title":"示例","index":"4.1"},{"id":"gif示例","title":"gif示例","index":"4.2"}]},{"id":"参考","title":"参考","index":"5"}],"reading_time":"2284 words in 15 min"}