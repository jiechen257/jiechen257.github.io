{"title":"状态管理工具的演变","date":"2022-05-27T21:47:50.000Z","date_formatted":{"ll":"May 27, 2022","L":"05/27/2022","MM-DD":"05-27"},"link":"2022/05/27/状态管理工具的演变","comments":true,"tags":["vue"],"categories":["front-end"],"updated":"2023-07-11T08:54:19.196Z","content":"<p>概述：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测</p>\n<h2 id=\"store模式\">Store模式<a title=\"#store模式\" href=\"#store模式\"></a></h2>\n<p>将状态存到一个外部变量， <code>this.$root.$data</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> store = &#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello!&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setMessageAction (newValue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发生改变记录点日志啥的</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span>.<span class=\"property\">message</span> = newValue</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  clearMessageAction () &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span>.<span class=\"property\">message</span> = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于store的state值改变方式（mutation）只有通过触发action来操作，因此可以很容易跟踪到state的改变流程，出现错误也能通过日志明确错误位置</p>\n<p><img src=\"http://cdn.becase.top/20220406124642.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><code>store并没有限制组件只能通过action来修改state</code><br>\n由这一点演化得出了 Flux 架构</p>\n<h2 id=\"flux\">Flux<a title=\"#flux\" href=\"#flux\"></a></h2>\n<p>Flux是类似于MVC、MVVM之类的一种思想，它把一个应用分成四个部分<br>\n——View、Action、Dispatcher、Store</p>\n<p><img src=\"http://cdn.becase.top/20220406125439.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>View视图层可以是通过vue或者react等框架实现，而View中的数据都是Store，Store改变就抛出一个事件，通知所有的订阅者（或者监听，不同的框架对应不同的数据响应技术）发生改变</p>\n<p>Flux要求，View要想修改Store，必须经过一套流程</p>\n<ol>\n<li>视图先要告诉Dispatcher，让Dispatcher dispatch 一个 action</li>\n<li>Dispatcher 收到 View 发出的 action，然后转发给Store</li>\n<li>Store就触发相应的action来更新数据</li>\n<li>数据更新则伴随着 View 的更新</li>\n</ol>\n<p><strong>注意：</strong></p>\n<ul>\n<li>Dispatcher的作用是接受<strong>所有</strong>的 Action。然后发给<strong>所有</strong>的 Store（Action可能是View触发的，也可能是其他地方触发的，如测试用例）</li>\n<li>Store的改变只能通过Action，Store不应该有公开的 Setter，所有的Setter都应该是私有的，只能有公开的 Getter</li>\n<li>具体Action的处理逻辑一般放在 Store 里</li>\n</ul>\n<p><strong>Flux 特点：</strong> <code>单向流动</code></p>\n<h2 id=\"redux\">Redux<a title=\"#redux\" href=\"#redux\"></a></h2>\n<p>与 Flux 思想类似，<br>\n但修改了 Flux 的一些特性：</p>\n<ul>\n<li>一个应用可以拥有多个Store</li>\n<li>多个Store间可能存在依赖关系</li>\n<li>Store 还封装了处理数据的逻辑</li>\n</ul>\n<p><img src=\"http://cdn.becase.top/20220406130703.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"store\">Store<a title=\"#store\" href=\"#store\"></a></h3>\n<p>Redux 里面只有一个 Store，整个应用的数据都在这个大 Store 里面。Store 的 State 不能直接修改，每次只能返回一个新的 State。Redux 整了一个 createStore 函数来生成 Store。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"title function_\">createStore</span>(fn);</span><br></pre></td></tr></table></figure>\n<p>Store 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。这样不管 View 是用什么实现的，只要把 View 的更新函数 subscribe 一下，就可以实现 State 变化之后，View 自动渲染了。比如在 React 里，把组件的render方法或setState方法订阅进去就行。</p>\n<h3 id=\"action\">Action<a title=\"#action\" href=\"#action\"></a></h3>\n<p>和 Flux 一样，Redux 里面也有 Action，Action 就是 View 发出的通知，告诉 Store State 要改变。Action 必须有一个 type 属性，代表 Action 的名称，其他可以设置一堆属性，作为参数供 State 变更时参考。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> action = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;ADD_TODO&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">payload</span>: <span class=\"string\">&#x27;Learn Redux&#x27;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Redux 可以用 Action Creator 批量来生成一些 Action。</p>\n<h3 id=\"reducer\">Reducer<a title=\"#reducer\" href=\"#reducer\"></a></h3>\n<p>Redux 没有 Dispatcher 的概念，Store 里面已经集成了 dispatch 方法。store.dispatch()是 View 发出 Action 的唯一方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"title function_\">createStore</span>(fn);</span><br><span class=\"line\"></span><br><span class=\"line\">store.<span class=\"title function_\">dispatch</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;ADD_TODO&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">payload</span>: <span class=\"string\">&#x27;Learn Redux&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Redux 用一个叫做 Reducer 的<strong>纯函数</strong>来处理事件。Store 收到 Action 以后，必须给出一个<strong>新的 State</strong>（就是刚才说的Store 的 State 不能直接修改，每次只能返回一个新的 State），这样 View 才会发生变化。这种 State 的计算过程就叫做 Reduce</p>\n<blockquote>\n<p>纯函数，即没有任何副作用</p>\n<ul>\n<li>对于相同的输入，永远都只会有相同发输出</li>\n<li>不会影响挖补的变量，也不会被外部变量影响</li>\n<li>不能改写参数</li>\n</ul>\n</blockquote>\n<p>Redux根据应用的状态和当前的 action 推导出新的 state：<code>(previousState, action) =&gt; newState</code></p>\n<p>类比 Flux：<code>(state, action) =&gt; state</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">question: 为什么叫做 Reducer 呢?</span><br><span class=\"line\">—— reduce 是一个函数式编程的概念，经常和 map 放在一起说，简单来说，map 就是映射，reduce 就是归纳。</span><br><span class=\"line\">映射就是把一个列表按照一定规则映射成另一个列表，而 reduce 是把一个列表通过一定规则进行合并，也可以理解为对初始值进行一系列的操作，返回一个新的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"整体流程\">整体流程<a title=\"#整体流程\" href=\"#整体流程\"></a></h3>\n<p>1、用户通过 View 发出 Action：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.<span class=\"title function_\">dispatch</span>(action);</span><br></pre></td></tr></table></figure>\n<p>2、然后 Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let nextState = xxxReducer(previousState, action);</span><br></pre></td></tr></table></figure>\n<p>3、State 一旦有变化，Store 就会调用监听函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.<span class=\"title function_\">subscribe</span>(listener);</span><br></pre></td></tr></table></figure>\n<p>4、listener可以通过 store.getState() 得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">listerner</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newState = store.<span class=\"title function_\">getState</span>();</span><br><span class=\"line\">  component.<span class=\"title function_\">setState</span>(newState);   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对比-flux\">对比 Flux<a title=\"#对比-flux\" href=\"#对比-flux\"></a></h3>\n<p>和 Flux 比较一下：Flux 中 Store 是各自为战的，每个 Store 只对对应的 View 负责，每次更新都只通知对应的View：</p>\n<p><img src=\"https://pic3.zhimg.com/v2-4f3428e4dbb2e0c5b1988275b82da14e_r.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>Redux 中各子 Reducer 都是由根 Reducer 统一管理的，每个子 Reducer 的变化都要经过根 Reducer 的整合：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-3eea040acf4cd03884ba3e903b936425_r.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>简单来说，Redux有三大原则： <em>单一数据源：Flux 的数据源可以是多个。</em> State 是只读的：Flux 的 State 可以随便改。 * 使用纯函数来执行修改：Flux 执行修改的不一定是纯函数。</p>\n<p>Redux 和 Flux 一样都是<strong>单向数据流</strong></p>\n<h3 id=\"与react-关系\">与React 关系<a title=\"#与react-关系\" href=\"#与react-关系\"></a></h3>\n<p>Redux 和 Flux 类似，只是一种思想或者规范，它和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。</p>\n<p>但是因为 React 包含函数式的思想，也是单向数据流，和 Redux 很搭，所以一般都用 Redux 来进行状态管理。为了简单处理 Redux 和 React UI 的绑定，一般通过一个叫 react-redux 的库和 React 配合使用，这个是 react 官方出的（如果不用 react-redux，那么手动处理 Redux 和 UI 的绑定，需要写很多重复的代码，很容易出错，而且有很多 UI 渲染逻辑的优化不一定能处理好）。</p>\n<p>Redux将React组件分为容器型组件和展示型组件，容器型组件一般通过connect函数生成，它订阅了全局状态的变化，通过mapStateToProps函数，可以对全局状态进行过滤，而展示型组件不直接从global state获取数据，其数据来源于父组件。</p>\n<p><img src=\"https://pic4.zhimg.com/v2-6c15a43f784be592052aff8e9f495643_r.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>如果一个组件既需要UI呈现，又需要业务逻辑处理，那就得拆，拆成一个容器组件包着一个展示组件。</p>\n<h2 id=\"redux-saga\">Redux-saga<a title=\"#redux-saga\" href=\"#redux-saga\"></a></h2>\n<p>Redux处理异步操作，添加中间件后的产物</p>\n<p>官方文档：<a href=\"https://redux-saga-in-chinese.js.org/\" target=\"_blank\">Redux-Saga</a></p>\n<h2 id=\"dva\">Dva<a title=\"#dva\" href=\"#dva\"></a></h2>\n<p>官方定义：dva 首先是一个基于 <a href=\"https://github.com/reduxjs/redux\" target=\"_blank\">redux</a> 和 <a href=\"https://github.com/redux-saga/redux-saga\" target=\"_blank\">redux-saga</a> 的数据流方案，然后为了简化开发体验，dva 还额外内置了 <a href=\"https://github.com/ReactTraining/react-router\" target=\"_blank\">react-router</a> 和 <a href=\"https://github.com/github/fetch\" target=\"_blank\">fetch</a>，所以也可以理解为一个轻量级的应用框架</p>\n<p>简单理解，就是让使用 react-redux 和 redux-saga 编写的代码组织起来更合理，维护起来更方便</p>\n<blockquote>\n<p>之前我们聊了 redux、react-redux、redux-saga 之类的概念，大家肯定觉得头昏脑涨的，什么 action、reducer、saga 之类的，写一个功能要在这些js文件里面不停的切换。dva 做的事情很简单，就是让这些东西可以写到一起，不用分开来写了</p>\n</blockquote>\n<p>比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以前书写的方式是创建 sagas/products.js, reducers/products.js 和actions/products.js，然后把 saga、action、reducer 啥的分开来写，来回切换</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">model</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// namespace - 对应 reducer 在 combine 到 rootReducer 时的 key 值</span></span><br><span class=\"line\">  <span class=\"attr\">namespace</span>: <span class=\"string\">&#x27;products&#x27;</span>,</span><br><span class=\"line\">  <span class=\"comment\">// state - 对应 reducer 的 initialState</span></span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">list</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">loading</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// subscription - 在 dom ready 后执行</span></span><br><span class=\"line\">  <span class=\"attr\">subscriptions</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">function</span>(<span class=\"params\">dispatch</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">dispatch</span>(&#123;<span class=\"attr\">type</span>: <span class=\"string\">&#x27;products/query&#x27;</span>&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"comment\">// effects - 对应 saga，并简化了使用</span></span><br><span class=\"line\">  <span class=\"attr\">effects</span>: &#123;</span><br><span class=\"line\">    [<span class=\"string\">&#x27;products/query&#x27;</span>]: <span class=\"keyword\">function</span>*() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> <span class=\"title function_\">call</span>(<span class=\"title function_\">delay</span>(<span class=\"number\">800</span>));</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> <span class=\"title function_\">put</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;products/query/success&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">payload</span>: [<span class=\"string\">&#x27;ant-tool&#x27;</span>, <span class=\"string\">&#x27;roof&#x27;</span>],</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// reducers - 就是传统的 reducers</span></span><br><span class=\"line\">  <span class=\"attr\">reducers</span>: &#123;</span><br><span class=\"line\">    [<span class=\"string\">&#x27;products/query&#x27;</span>](state) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; ...state, <span class=\"attr\">loading</span>: <span class=\"literal\">true</span>, &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [<span class=\"string\">&#x27;products/query/success&#x27;</span>](state, &#123; payload &#125;) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; ...state, <span class=\"attr\">loading</span>: <span class=\"literal\">false</span>, <span class=\"attr\">list</span>: payload &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"mobx\">MobX<a title=\"#mobx\" href=\"#mobx\"></a></h2>\n<p>官网：<a href=\"https://cn.mobx.js.org/\" target=\"_blank\">MobX 中文文档</a></p>\n<p>对比 Flux 体系的单向数据流方案，Mobx 的思想则是 ：<strong>任何源自应用状态的东西都应该自动地获得</strong> ——状态只要一变，其他用到状态的地方就都跟着自动变</p>\n<p><img src=\"http://cdn.becase.top/20220406133523.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>Flux 或者说 Redux 的思想主要就是函数式编程（FP）的思想，所以学习起来会觉得累一些。而 MobX 更接近于面向对象编程，它把 state 包装成可观察的对象，这个对象会驱动各种改变。什么是可观察？就是 MobX 老大哥在看着 state 呢。state 只要一改变，所有用到它的地方就都跟着改变了。这样整个 View 可以被 state 来驱动。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"title function_\">observable</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">autoRun</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">a</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">b</span> = <span class=\"number\">3</span> <span class=\"comment\">// 什么都没有发生</span></span><br><span class=\"line\">obj.<span class=\"property\">a</span> = <span class=\"number\">2</span> <span class=\"comment\">// observe 函数的回调触发了，控制台输出：2</span></span><br></pre></td></tr></table></figure>\n<p>上面的obj，他的 obj.a 属性被使用了，那么只要 obj.a 属性一变，所有使用的地方都会被调用。autoRun 就是这个老大哥，他看着所有依赖 obj.a 的地方，也就是<strong>收集</strong>所有对 obj.a 的<strong>依赖</strong>。当 obj.a 改变时，老大哥就会触发所有依赖去更新</p>\n<p>MobX 和 Flux、Redux 一样，都是和具体的前端框架无关的，也就是说可以用于 React（mobx-react) 或者 Vue（mobx-vue)。一般来说，用到 React 比较常见，很少用于 Vue，因为 Vuex 本身就类似 MobX，很灵活。如果我们把 MobX 用于 React 或者 Vue，可以看到很多 setState() 和 <a href=\"http://this.state.xxx\">this.state.xxx</a> = 这样的处理都可以省了。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/53599723\" target=\"_blank\">Vuex、Flux、Redux、Redux-saga、Dva、MobX</a></p>\n","prev":{"title":"SSL建立的三个随机数作用","link":"2022/05/27/SSL建立的三个随机数作用"},"next":{"title":"http协议的发展历程","link":"2022/05/26/http协议的发展历程"},"plink":"https://becase.top/2022/05/27/状态管理工具的演变/","toc":[{"id":"store模式","title":"Store模式","index":"1"},{"id":"flux","title":"Flux","index":"2"},{"id":"redux","title":"Redux","index":"3","children":[{"id":"store","title":"Store","index":"3.1"},{"id":"action","title":"Action","index":"3.2"},{"id":"reducer","title":"Reducer","index":"3.3"},{"id":"整体流程","title":"整体流程","index":"3.4"},{"id":"对比-flux","title":"对比 Flux","index":"3.5"},{"id":"与react-关系","title":"与React 关系","index":"3.6"}]},{"id":"redux-saga","title":"Redux-saga","index":"4"},{"id":"dva","title":"Dva","index":"5"},{"id":"mobx","title":"MobX","index":"6"},{"id":"参考","title":"参考","index":"7"}],"reading_time":"2479 words in 17 min"}